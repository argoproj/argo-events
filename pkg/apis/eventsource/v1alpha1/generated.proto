/*
Copyright 2020 BlackRock, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.argoproj.argo_events.pkg.apis.eventsource.v1alpha1;

import "github.com/argoproj/argo-events/pkg/apis/common/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1alpha1";

// AMQPConsumeConfig holds the configuration to immediately starts delivering queued messages
// +k8s:openapi-gen=true
message AMQPConsumeConfig {
  // ConsumerTag is the identity of the consumer included in every delivery
  // +optional
  optional string consumerTag = 1;

  // AutoAck when true, the server will acknowledge deliveries to this consumer prior to writing
  // the delivery to the network
  // +optional
  optional bool autoAck = 2;

  // Exclusive when true, the server will ensure that this is the sole consumer from this queue
  // +optional
  optional bool exclusive = 3;

  // NoLocal flag is not supported by RabbitMQ
  // +optional
  optional bool noLocal = 4;

  // NowWait when true, do not wait for the server to confirm the request and immediately begin deliveries
  // +optional
  optional bool noWait = 5;
}

// AMQPEventSource refers to an event-source for AMQP stream events
message AMQPEventSource {
  // URL for rabbitmq service
  optional string url = 1;

  // ExchangeName is the exchange name
  // For more information, visit https://www.rabbitmq.com/tutorials/amqp-concepts.html
  optional string exchangeName = 2;

  // ExchangeType is rabbitmq exchange type
  optional string exchangeType = 3;

  // Routing key for bindings
  optional string routingKey = 4;

  // Backoff holds parameters applied to connection.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 5;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 6;

  // TLS configuration for the amqp client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 7;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 8;

  // ExchangeDeclare holds the configuration for the exchange on the server
  // For more information, visit https://godoc.org/github.com/streadway/amqp#Channel.ExchangeDeclare
  // +optional
  optional AMQPExchangeDeclareConfig exchangeDeclare = 9;

  // QueueDeclare holds the configuration of a queue to hold messages and deliver to consumers.
  // Declaring creates a queue if it doesn't already exist, or ensures that an existing queue matches
  // the same parameters
  // For more information, visit https://godoc.org/github.com/streadway/amqp#Channel.QueueDeclare
  // +optional
  optional AMQPQueueDeclareConfig queueDeclare = 10;

  // QueueBind holds the configuration that binds an exchange to a queue so that publishings to the
  // exchange will be routed to the queue when the publishing routing key matches the binding routing key
  // For more information, visit https://godoc.org/github.com/streadway/amqp#Channel.QueueBind
  // +optional
  optional AMQPQueueBindConfig queueBind = 11;

  // Consume holds the configuration to immediately starts delivering queued messages
  // For more information, visit https://godoc.org/github.com/streadway/amqp#Channel.Consume
  // +optional
  optional AMQPConsumeConfig consume = 12;
}

// AMQPExchangeDeclareConfig holds the configuration for the exchange on the server
// +k8s:openapi-gen=true
message AMQPExchangeDeclareConfig {
  // Durable keeps the exchange also after the server restarts
  // +optional
  optional bool durable = 1;

  // AutoDelete removes the exchange when no bindings are active
  // +optional
  optional bool autoDelete = 2;

  // Internal when true does not accept publishings
  // +optional
  optional bool internal = 3;

  // NowWait when true does not wait for a confirmation from the server
  // +optional
  optional bool noWait = 4;
}

// AMQPQueueBindConfig holds the configuration that binds an exchange to a queue so that publishings to the
// exchange will be routed to the queue when the publishing routing key matches the binding routing key
// +k8s:openapi-gen=true
message AMQPQueueBindConfig {
  // NowWait false and the queue could not be bound, the channel will be closed with an error
  // +optional
  optional bool noWait = 1;
}

// AMQPQueueDeclareConfig holds the configuration of a queue to hold messages and deliver to consumers.
// Declaring creates a queue if it doesn't already exist, or ensures that an existing queue matches
// the same parameters
// +k8s:openapi-gen=true
message AMQPQueueDeclareConfig {
  // Name of the queue. If empty the server auto-generates a unique name for this queue
  // +optional
  optional string name = 1;

  // Durable keeps the queue also after the server restarts
  // +optional
  optional bool durable = 2;

  // AutoDelete removes the queue when no consumers are active
  // +optional
  optional bool autoDelete = 3;

  // Exclusive sets the queues to be accessible only by the connection that declares them and will be
  // deleted wgen the connection closes
  // +optional
  optional bool exclusive = 4;

  // NowWait when true, the queue assumes to be declared on the server
  // +optional
  optional bool noWait = 5;
}

// AzureEventsHubEventSource describes the event source for azure events hub
// More info at https://docs.microsoft.com/en-us/azure/event-hubs/
message AzureEventsHubEventSource {
  // FQDN of the EventHubs namespace you created
  // More info at https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string
  optional string fqdn = 1;

  // SharedAccessKeyName is the name you chose for your application's SAS keys
  optional k8s.io.api.core.v1.SecretKeySelector sharedAccessKeyName = 2;

  // SharedAccessKey is the generated value of the key
  optional k8s.io.api.core.v1.SecretKeySelector sharedAccessKey = 3;

  // Event Hub path/name
  optional string hubName = 4;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 5;
}

// CalendarEventSource describes a time based dependency. One of the fields (schedule, interval, or recurrence) must be passed.
// Schedule takes precedence over interval; interval takes precedence over recurrence
message CalendarEventSource {
  // Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron
  optional string schedule = 1;

  // Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...
  optional string interval = 2;

  repeated string exclusionDates = 3;

  // Timezone in which to run the schedule
  // +optional
  optional string timezone = 4;

  // UserPayload will be sent to sensor as extra data once the event is triggered
  // +optional
  // Deprecated: will be removed in v1.5. Please use Metadata instead.
  optional bytes userPayload = 5;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 6;

  // Persistence hold the configuration for event persistence
  optional EventPersistence persistence = 7;
}

message CatchupConfiguration {
  // Enabled enables to triggered the missed schedule when eventsource restarts
  optional bool enabled = 1;

  // MaxDuration holds max catchup duration
  optional string maxDuration = 2;
}

message ConfigMapPersistence {
  // Name of the configmap
  optional string name = 1;

  // CreateIfNotExist will create configmap if it doesn't exists
  optional bool createIfNotExist = 2;
}

// EmitterEventSource describes the event source for emitter
// More info at https://emitter.io/develop/getting-started/
message EmitterEventSource {
  // Broker URI to connect to.
  optional string broker = 1;

  // ChannelKey refers to the channel key
  optional string channelKey = 2;

  // ChannelName refers to the channel name
  optional string channelName = 3;

  // Username to use to connect to broker
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector username = 4;

  // Password to use to connect to broker
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 5;

  // Backoff holds parameters applied to connection.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 6;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 7;

  // TLS configuration for the emitter client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 8;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 9;
}

message EventPersistence {
  // Catchup enables to triggered the missed schedule when eventsource restarts
  optional CatchupConfiguration catchup = 1;

  // ConfigMap holds configmap details for persistence
  optional ConfigMapPersistence configMap = 2;
}

// EventSource is the definition of a eventsource resource
// +genclient
// +kubebuilder:resource:shortName=es
// +kubebuilder:subresource:status
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
message EventSource {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

  optional EventSourceSpec spec = 2;

  // +optional
  optional EventSourceStatus status = 3;
}

// EventSourceList is the list of eventsource resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message EventSourceList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

  repeated EventSource items = 2;
}

// EventSourceSpec refers to specification of event-source resource
message EventSourceSpec {
  // EventBusName references to a EventBus name. By default the value is "default"
  optional string eventBusName = 1;

  // Template is the pod specification for the event source
  // +optional
  optional Template template = 2;

  // Service is the specifications of the service to expose the event source
  // +optional
  optional Service service = 3;

  // DeprecatedReplica is the event source deployment replicas
  // Deprecated: use replicas instead, will be removed in v1.5
  optional int32 replica = 4;

  // Minio event sources
  map<string, github.com.argoproj.argo_events.pkg.apis.common.S3Artifact> minio = 5;

  // Calendar event sources
  map<string, CalendarEventSource> calendar = 6;

  // File event sources
  map<string, FileEventSource> file = 7;

  // Resource event sources
  map<string, ResourceEventSource> resource = 8;

  // Webhook event sources
  map<string, WebhookContext> webhook = 9;

  // AMQP event sources
  map<string, AMQPEventSource> amqp = 10;

  // Kafka event sources
  map<string, KafkaEventSource> kafka = 11;

  // MQTT event sources
  map<string, MQTTEventSource> mqtt = 12;

  // NATS event sources
  map<string, NATSEventsSource> nats = 13;

  // SNS event sources
  map<string, SNSEventSource> sns = 14;

  // SQS event sources
  map<string, SQSEventSource> sqs = 15;

  // PubSub event sources
  map<string, PubSubEventSource> pubSub = 16;

  // Github event sources
  map<string, GithubEventSource> github = 17;

  // Gitlab event sources
  map<string, GitlabEventSource> gitlab = 18;

  // HDFS event sources
  map<string, HDFSEventSource> hdfs = 19;

  // Slack event sources
  map<string, SlackEventSource> slack = 20;

  // StorageGrid event sources
  map<string, StorageGridEventSource> storageGrid = 21;

  // AzureEventsHub event sources
  map<string, AzureEventsHubEventSource> azureEventsHub = 22;

  // Stripe event sources
  map<string, StripeEventSource> stripe = 23;

  // Emitter event source
  map<string, EmitterEventSource> emitter = 24;

  // Redis event source
  map<string, RedisEventSource> redis = 25;

  // NSQ event source
  map<string, NSQEventSource> nsq = 26;

  // Pulsar event source
  map<string, PulsarEventSource> pulsar = 27;

  // Generic event source
  map<string, GenericEventSource> generic = 28;

  // Replicas is the event source deployment replicas
  optional int32 replicas = 29;
}

// EventSourceStatus holds the status of the event-source resource
message EventSourceStatus {
  optional github.com.argoproj.argo_events.pkg.apis.common.Status status = 1;
}

// FileEventSource describes an event-source for file related events.
message FileEventSource {
  // Type of file operations to watch
  // Refer https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information
  optional string eventType = 1;

  // WatchPathConfig contains configuration about the file path to watch
  optional WatchPathConfig watchPathConfig = 2;

  // Use polling instead of inotify
  optional bool polling = 3;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 4;
}

// GenericEventSource refers to a generic event source. It can be used to implement a custom event source.
message GenericEventSource {
  // URL of the gRPC server that implements the event source.
  optional string url = 1;

  // Config is the event source configuration
  optional string config = 2;

  // Insecure determines the type of connection.
  optional bool insecure = 3;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 4;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 5;

  // AuthSecret holds a secret selector that contains a bearer token for authentication
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector authSecret = 6;
}

// GithubEventSource refers to event-source for github related events
message GithubEventSource {
  // Id is the webhook's id
  optional int64 id = 1;

  // Webhook refers to the configuration required to run a http server
  optional WebhookContext webhook = 2;

  // Owner refers to GitHub owner name i.e. argoproj
  optional string owner = 3;

  // Repository refers to GitHub repo name i.e. argo-events
  optional string repository = 4;

  repeated string events = 5;

  // APIToken refers to a K8s secret containing github api token
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector apiToken = 6;

  // WebhookSecret refers to K8s secret containing GitHub webhook secret
  // https://developer.github.com/webhooks/securing/
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector webhookSecret = 7;

  // Insecure tls verification
  optional bool insecure = 8;

  // Active refers to status of the webhook for event deliveries.
  // https://developer.github.com/webhooks/creating/#active
  // +optional
  optional bool active = 9;

  // ContentType of the event delivery
  optional string contentType = 10;

  // GitHub base URL (for GitHub Enterprise)
  // +optional
  optional string githubBaseURL = 11;

  // GitHub upload URL (for GitHub Enterprise)
  // +optional
  optional string githubUploadURL = 12;

  // DeleteHookOnFinish determines whether to delete the GitHub hook for the repository once the event source is stopped.
  // +optional
  optional bool deleteHookOnFinish = 13;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 14;
}

// GitlabEventSource refers to event-source related to Gitlab events
message GitlabEventSource {
  // Webhook holds configuration to run a http server
  optional WebhookContext webhook = 1;

  // ProjectID is the id of project for which integration needs to setup
  optional string projectID = 2;

  // Events are gitlab event to listen to.
  // Refer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.
  repeated string events = 3;

  // AccessToken is reference to k8 secret which holds the gitlab api access information
  optional k8s.io.api.core.v1.SecretKeySelector accessToken = 4;

  // EnableSSLVerification to enable ssl verification
  // +optional
  optional bool enableSSLVerification = 5;

  // GitlabBaseURL is the base URL for API requests to a custom endpoint
  optional string gitlabBaseURL = 6;

  // DeleteHookOnFinish determines whether to delete the GitLab hook for the project once the event source is stopped.
  // +optional
  optional bool deleteHookOnFinish = 8;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 9;
}

// HDFSEventSource refers to event-source for HDFS related events
message HDFSEventSource {
  optional WatchPathConfig watchPathConfig = 1;

  // Type of file operations to watch
  optional string type = 2;

  // CheckInterval is a string that describes an interval duration to check the directory state, e.g. 1s, 30m, 2h... (defaults to 1m)
  optional string checkInterval = 3;

  repeated string addresses = 4;

  // HDFSUser is the user to access HDFS file system.
  // It is ignored if either ccache or keytab is used.
  optional string hdfsUser = 5;

  // KrbCCacheSecret is the secret selector for Kerberos ccache
  // Either ccache or keytab can be set to use Kerberos.
  optional k8s.io.api.core.v1.SecretKeySelector krbCCacheSecret = 6;

  // KrbKeytabSecret is the secret selector for Kerberos keytab
  // Either ccache or keytab can be set to use Kerberos.
  optional k8s.io.api.core.v1.SecretKeySelector krbKeytabSecret = 7;

  // KrbUsername is the Kerberos username used with Kerberos keytab
  // It must be set if keytab is used.
  optional string krbUsername = 8;

  // KrbRealm is the Kerberos realm used with Kerberos keytab
  // It must be set if keytab is used.
  optional string krbRealm = 9;

  // KrbConfig is the configmap selector for Kerberos config as string
  // It must be set if either ccache or keytab is used.
  optional k8s.io.api.core.v1.ConfigMapKeySelector krbConfigConfigMap = 10;

  // KrbServicePrincipalName is the principal name of Kerberos service
  // It must be set if either ccache or keytab is used.
  optional string krbServicePrincipalName = 11;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 12;
}

message KafkaConsumerGroup {
  // The name for the consumer group to use
  optional string groupName = 1;

  // When starting up a new group do we want to start from the oldest event (true) or the newest event (false), defaults to false
  // +optional
  optional bool oldest = 2;

  // Rebalance strategy can be one of: sticky, roundrobin, range. Range is the default.
  // +optional
  optional string rebalanceStrategy = 3;
}

// KafkaEventSource refers to event-source for Kafka related events
message KafkaEventSource {
  // URL to kafka cluster, multiple URLs separated by comma
  optional string url = 1;

  // Partition name
  optional string partition = 2;

  // Topic name
  optional string topic = 3;

  // Backoff holds parameters applied to connection.
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 4;

  // TLS configuration for the kafka client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 5;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;

  // Consumer group for kafka client
  // +optional
  optional KafkaConsumerGroup consumerGroup = 8;

  // Sets a limit on how many events get read from kafka per second.
  // +optional
  optional int64 limitEventsPerSecond = 9;

  // Specify what kafka version is being connected to enables certain features in sarama, defaults to 1.0.0
  // +optional
  optional string version = 10;

  // SASL configuration for the kafka client
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.SASLConfig sasl = 11;
}

// MQTTEventSource refers to event-source for MQTT related events
message MQTTEventSource {
  // URL to connect to broker
  optional string url = 1;

  // Topic name
  optional string topic = 2;

  // ClientID is the id of the client
  optional string clientId = 3;

  // ConnectionBackoff holds backoff applied to connection.
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 4;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 5;

  // TLS configuration for the mqtt client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;
}

// NATSAuth refers to the auth info for NATS EventSource
message NATSAuth {
  // Baisc auth with username and password
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.BasicAuth basic = 1;

  // Token used to connect
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector token = 2;

  // NKey used to connect
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector nkey = 3;

  // credential used to connect
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector credential = 4;
}

// NATSEventsSource refers to event-source for NATS related events
message NATSEventsSource {
  // URL to connect to NATS cluster
  optional string url = 1;

  // Subject holds the name of the subject onto which messages are published
  optional string subject = 2;

  // ConnectionBackoff holds backoff applied to connection.
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 3;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 4;

  // TLS configuration for the nats client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 5;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 6;

  // Auth information
  // +optional
  optional NATSAuth auth = 7;
}

// NSQEventSource describes the event source for NSQ PubSub
// More info at https://godoc.org/github.com/nsqio/go-nsq
message NSQEventSource {
  // HostAddress is the address of the host for NSQ lookup
  optional string hostAddress = 1;

  // Topic to subscribe to.
  optional string topic = 2;

  // Channel used for subscription
  optional string channel = 3;

  // Backoff holds parameters applied to connection.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 4;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 5;

  // TLS configuration for the nsq client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;
}

// PubSubEventSource refers to event-source for GCP PubSub related events.
message PubSubEventSource {
  // ProjectID is GCP project ID for the subscription.
  // Required if you run Argo Events outside of GKE/GCE.
  // (otherwise, the default value is its project)
  // +optional
  optional string projectID = 1;

  // TopicProjectID is GCP project ID for the topic.
  // By default, it is same as ProjectID.
  // +optional
  optional string topicProjectID = 2;

  // Topic to which the subscription should belongs.
  // Required if you want the eventsource to create a new subscription.
  // If you specify this field along with an existing subscription,
  // it will be verified whether it actually belongs to the specified topic.
  // +optional
  optional string topic = 3;

  // SubscriptionID is ID of subscription.
  // Required if you use existing subscription.
  // The default value will be auto generated hash based on this eventsource setting, so the subscription
  // might be recreated every time you update the setting, which has a possibility of event loss.
  // +optional
  optional string subscriptionID = 4;

  // CredentialSecret references to the secret that contains JSON credentials to access GCP.
  // If it is missing, it implicitly uses Workload Identity to access.
  // https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector credentialSecret = 5;

  // DeleteSubscriptionOnFinish determines whether to delete the GCP PubSub subscription once the event source is stopped.
  // +optional
  optional bool deleteSubscriptionOnFinish = 6;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 7;

  // CredentialsFile is the file that contains credentials to authenticate for GCP
  // Deprecated: will be removed in v1.5, use CredentialSecret instead
  optional string credentialsFile = 8;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 9;
}

// PulsarEventSource describes the event source for Apache Pulsar
message PulsarEventSource {
  // Name of the topics to subscribe to.
  // +required
  repeated string topics = 1;

  // Type of the subscription.
  // Only "exclusive" and "shared" is supported.
  // Defaults to exclusive.
  // +optional
  optional string type = 2;

  // Configure the service URL for the Pulsar service.
  // +required
  optional string url = 3;

  // Trusted TLS certificate secret.
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector tlsTrustCertsSecret = 4;

  // Whether the Pulsar client accept untrusted TLS certificate from broker.
  // +optional
  optional bool tlsAllowInsecureConnection = 5;

  // Whether the Pulsar client verify the validity of the host name from broker.
  // +optional
  optional bool tlsValidateHostname = 6;

  // TLS configuration for the pulsar client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 7;

  // Backoff holds parameters applied to connection.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.Backoff connectionBackoff = 8;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 9;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 10;
}

// RedisEventSource describes an event source for the Redis PubSub.
// More info at https://godoc.org/github.com/go-redis/redis#example-PubSub
message RedisEventSource {
  // HostAddress refers to the address of the Redis host/server
  optional string hostAddress = 1;

  // Password required for authentication if any.
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector password = 2;

  // Namespace to use to retrieve the password from. It should only be specified if password is declared
  // +optional
  optional string namespace = 3;

  // DB to use. If not specified, default DB 0 will be used.
  // +optional
  optional int32 db = 4;

  repeated string channels = 5;

  // TLS configuration for the redis client.
  // +optional
  optional github.com.argoproj.argo_events.pkg.apis.common.TLSConfig tls = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;
}

// ResourceEventSource refers to a event-source for K8s resource related events.
message ResourceEventSource {
  // Namespace where resource is deployed
  optional string namespace = 1;

  // Filter is applied on the metadata of the resource
  // If you apply filter, then the internal event informer will only monitor objects that pass the filter.
  // +optional
  optional ResourceFilter filter = 2;

  // Group of the resource
  optional k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionResource groupVersionResource = 3;

  // EventTypes is the list of event type to watch.
  // Possible values are - ADD, UPDATE and DELETE.
  repeated string eventTypes = 4;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 5;
}

// ResourceFilter contains K8 ObjectMeta information to further filter resource event objects
message ResourceFilter {
  // Prefix filter is applied on the resource name.
  // +optional
  optional string prefix = 1;

  // Labels provide listing options to K8s API to watch resource/s.
  // Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/label-selectors/ for more info.
  // +optional
  repeated Selector labels = 2;

  // Fields provide field filters similar to K8s field selector
  // (see https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/).
  // Unlike K8s field selector, it supports arbitrary fileds like "spec.serviceAccountName",
  // and the value could be a string or a regex.
  // Same as K8s field selector, operator "=", "==" and "!=" are supported.
  // +optional
  repeated Selector fields = 3;

  // If resource is created before the specified time then the event is treated as valid.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time createdBy = 4;

  // If the resource is created after the start time then the event is treated as valid.
  // +optional
  optional bool afterStart = 5;
}

// SNSEventSource refers to event-source for AWS SNS related events
message SNSEventSource {
  // Webhook configuration for http server
  optional WebhookContext webhook = 1;

  // TopicArn
  optional string topicArn = 2;

  // AccessKey refers K8 secret containing aws access key
  optional k8s.io.api.core.v1.SecretKeySelector accessKey = 3;

  // SecretKey refers K8 secret containing aws secret key
  optional k8s.io.api.core.v1.SecretKeySelector secretKey = 4;

  // Region is AWS region
  optional string region = 5;

  // RoleARN is the Amazon Resource Name (ARN) of the role to assume.
  // +optional
  optional string roleARN = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;

  // ValidateSignature is boolean that can be set to true for SNS signature verification
  // +optional
  optional bool validateSignature = 8;
}

// SQSEventSource refers to event-source for AWS SQS related events
message SQSEventSource {
  // AccessKey refers K8 secret containing aws access key
  optional k8s.io.api.core.v1.SecretKeySelector accessKey = 1;

  // SecretKey refers K8 secret containing aws secret key
  optional k8s.io.api.core.v1.SecretKeySelector secretKey = 2;

  // Region is AWS region
  optional string region = 3;

  // Queue is AWS SQS queue to listen to for messages
  optional string queue = 4;

  // WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive
  // in the queue before returning.
  optional int64 waitTimeSeconds = 5;

  // RoleARN is the Amazon Resource Name (ARN) of the role to assume.
  // +optional
  optional string roleARN = 6;

  // JSONBody specifies that all event body payload coming from this
  // source will be JSON
  // +optional
  optional bool jsonBody = 7;

  // QueueAccountID is the ID of the account that created the queue to monitor
  // +optional
  optional string queueAccountId = 8;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 9;
}

// Selector represents conditional operation to select K8s objects.
message Selector {
  // Key name
  optional string key = 1;

  // Supported operations like ==, !=, <=, >= etc.
  // Defaults to ==.
  // Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors for more info.
  // +optional
  optional string operation = 2;

  // Value
  optional string value = 3;
}

// Service holds the service information eventsource exposes
message Service {
  // The list of ports that are exposed by this ClusterIP service.
  // +patchMergeKey=port
  // +patchStrategy=merge
  // +listType=map
  // +listMapKey=port
  // +listMapKey=protocol
  repeated k8s.io.api.core.v1.ServicePort ports = 1;

  // clusterIP is the IP address of the service and is usually assigned
  // randomly by the master. If an address is specified manually and is not in
  // use by others, it will be allocated to the service; otherwise, creation
  // of the service will fail. This field can not be changed through updates.
  // Valid values are "None", empty string (""), or a valid IP address. "None"
  // can be specified for headless services when proxying is not required.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  // +optional
  optional string clusterIP = 2;
}

// SlackEventSource refers to event-source for Slack related events
message SlackEventSource {
  // Slack App signing secret
  optional k8s.io.api.core.v1.SecretKeySelector signingSecret = 1;

  // Token for URL verification handshake
  optional k8s.io.api.core.v1.SecretKeySelector token = 2;

  // Webhook holds configuration for a REST endpoint
  optional WebhookContext webhook = 3;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 4;
}

// StorageGridEventSource refers to event-source for StorageGrid related events
message StorageGridEventSource {
  // Webhook holds configuration for a REST endpoint
  optional WebhookContext webhook = 1;

  repeated string events = 2;

  // Filter on object key which caused the notification.
  optional StorageGridFilter filter = 3;

  // TopicArn
  optional string topicArn = 4;

  // Name of the bucket to register notifications for.
  optional string bucket = 5;

  // S3 region.
  // Defaults to us-east-1
  // +optional
  optional string region = 6;

  // Auth token for storagegrid api
  optional k8s.io.api.core.v1.SecretKeySelector authToken = 7;

  // APIURL is the url of the storagegrid api.
  optional string apiURL = 8;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 9;
}

// StorageGridFilter represents filters to apply to bucket notifications for specifying constraints on objects
// +k8s:openapi-gen=true
message StorageGridFilter {
  optional string prefix = 1;

  optional string suffix = 2;
}

// StripeEventSource describes the event source for stripe webhook notifications
// More info at https://stripe.com/docs/webhooks
message StripeEventSource {
  // Webhook holds configuration for a REST endpoint
  optional WebhookContext webhook = 1;

  // CreateWebhook if specified creates a new webhook programmatically.
  // +optional
  optional bool createWebhook = 2;

  // APIKey refers to K8s secret that holds Stripe API key. Used only if CreateWebhook is enabled.
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector apiKey = 3;

  // EventFilter describes the type of events to listen to. If not specified, all types of events will be processed.
  // More info at https://stripe.com/docs/api/events/list
  // +optional
  repeated string eventFilter = 4;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 5;
}

// Template holds the information of an EventSource deployment template
message Template {
  // Metadata sets the pods's metadata, i.e. annotations and labels
  optional github.com.argoproj.argo_events.pkg.apis.common.Metadata metadata = 1;

  // ServiceAccountName is the name of the ServiceAccount to use to run event source pod.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  // +optional
  optional string serviceAccountName = 2;

  // Container is the main container image to run in the event source pod
  // +optional
  optional k8s.io.api.core.v1.Container container = 3;

  // Volumes is a list of volumes that can be mounted by containers in an eventsource.
  // +patchStrategy=merge
  // +patchMergeKey=name
  // +optional
  repeated k8s.io.api.core.v1.Volume volumes = 4;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  // +optional
  optional k8s.io.api.core.v1.PodSecurityContext securityContext = 5;

  // If specified, the pod's scheduling constraints
  // +optional
  optional k8s.io.api.core.v1.Affinity affinity = 6;

  // If specified, the pod's tolerations.
  // +optional
  repeated k8s.io.api.core.v1.Toleration tolerations = 7;

  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  // +optional
  map<string, string> nodeSelector = 8;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use. For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 9;

  // If specified, indicates the EventSource pod's priority. "system-node-critical"
  // and "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional string priorityClassName = 10;

  // The priority value. Various system components use this field to find the
  // priority of the EventSource pod. When Priority Admission Controller is enabled,
  // it prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  // More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  // +optional
  optional int32 priority = 11;
}

message WatchPathConfig {
  // Directory to watch for events
  optional string directory = 1;

  // Path is relative path of object to watch with respect to the directory
  optional string path = 2;

  // PathRegexp is regexp of relative path of object to watch with respect to the directory
  optional string pathRegexp = 3;
}

// WebhookContext holds a general purpose REST API context
message WebhookContext {
  // REST API endpoint
  optional string endpoint = 1;

  // Method is HTTP request method that indicates the desired action to be performed for a given resource.
  // See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content
  optional string method = 2;

  // Port on which HTTP server is listening for incoming events.
  optional string port = 3;

  // URL is the url of the server.
  optional string url = 4;

  // ServerCertPath refers the file that contains the cert.
  optional k8s.io.api.core.v1.SecretKeySelector serverCertSecret = 5;

  // ServerKeyPath refers the file that contains private key
  optional k8s.io.api.core.v1.SecretKeySelector serverKeySecret = 6;

  // Metadata holds the user defined metadata which will passed along the event payload.
  // +optional
  map<string, string> metadata = 7;

  // AuthSecret holds a secret selector that contains a bearer token for authentication
  // +optional
  optional k8s.io.api.core.v1.SecretKeySelector authSecret = 8;

  // DeprecatedServerCertPath refers the file that contains the cert.
  optional string serverCertPath = 9;

  // DeprecatedServerKeyPath refers the file that contains private key
  optional string serverKeyPath = 10;
}

