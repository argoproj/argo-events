/*
Copyright 2020 BlackRock, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1/generated.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"

	io "io"

	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	v1 "k8s.io/api/core/v1"
	v11 "k8s.io/apimachinery/pkg/apis/meta/v1"

	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	k8s_io_apimachinery_pkg_types "k8s.io/apimachinery/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func (m *AWSLambdaTrigger) Reset()      { *m = AWSLambdaTrigger{} }
func (*AWSLambdaTrigger) ProtoMessage() {}
func (*AWSLambdaTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{0}
}
func (m *AWSLambdaTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSLambdaTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSLambdaTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSLambdaTrigger.Merge(m, src)
}
func (m *AWSLambdaTrigger) XXX_Size() int {
	return m.Size()
}
func (m *AWSLambdaTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSLambdaTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_AWSLambdaTrigger proto.InternalMessageInfo

func (m *ArgoWorkflowTrigger) Reset()      { *m = ArgoWorkflowTrigger{} }
func (*ArgoWorkflowTrigger) ProtoMessage() {}
func (*ArgoWorkflowTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{1}
}
func (m *ArgoWorkflowTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgoWorkflowTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ArgoWorkflowTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgoWorkflowTrigger.Merge(m, src)
}
func (m *ArgoWorkflowTrigger) XXX_Size() int {
	return m.Size()
}
func (m *ArgoWorkflowTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgoWorkflowTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_ArgoWorkflowTrigger proto.InternalMessageInfo

func (m *ArtifactLocation) Reset()      { *m = ArtifactLocation{} }
func (*ArtifactLocation) ProtoMessage() {}
func (*ArtifactLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{2}
}
func (m *ArtifactLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArtifactLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ArtifactLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArtifactLocation.Merge(m, src)
}
func (m *ArtifactLocation) XXX_Size() int {
	return m.Size()
}
func (m *ArtifactLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ArtifactLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ArtifactLocation proto.InternalMessageInfo

func (m *Backoff) Reset()      { *m = Backoff{} }
func (*Backoff) ProtoMessage() {}
func (*Backoff) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{3}
}
func (m *Backoff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Backoff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Backoff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Backoff.Merge(m, src)
}
func (m *Backoff) XXX_Size() int {
	return m.Size()
}
func (m *Backoff) XXX_DiscardUnknown() {
	xxx_messageInfo_Backoff.DiscardUnknown(m)
}

var xxx_messageInfo_Backoff proto.InternalMessageInfo

func (m *BasicAuth) Reset()      { *m = BasicAuth{} }
func (*BasicAuth) ProtoMessage() {}
func (*BasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{4}
}
func (m *BasicAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuth.Merge(m, src)
}
func (m *BasicAuth) XXX_Size() int {
	return m.Size()
}
func (m *BasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuth proto.InternalMessageInfo

func (m *ConfigmapArtifact) Reset()      { *m = ConfigmapArtifact{} }
func (*ConfigmapArtifact) ProtoMessage() {}
func (*ConfigmapArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{5}
}
func (m *ConfigmapArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigmapArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfigmapArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigmapArtifact.Merge(m, src)
}
func (m *ConfigmapArtifact) XXX_Size() int {
	return m.Size()
}
func (m *ConfigmapArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigmapArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigmapArtifact proto.InternalMessageInfo

func (m *CustomTrigger) Reset()      { *m = CustomTrigger{} }
func (*CustomTrigger) ProtoMessage() {}
func (*CustomTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{6}
}
func (m *CustomTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomTrigger.Merge(m, src)
}
func (m *CustomTrigger) XXX_Size() int {
	return m.Size()
}
func (m *CustomTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_CustomTrigger proto.InternalMessageInfo

func (m *DataFilter) Reset()      { *m = DataFilter{} }
func (*DataFilter) ProtoMessage() {}
func (*DataFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{7}
}
func (m *DataFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DataFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFilter.Merge(m, src)
}
func (m *DataFilter) XXX_Size() int {
	return m.Size()
}
func (m *DataFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFilter.DiscardUnknown(m)
}

var xxx_messageInfo_DataFilter proto.InternalMessageInfo

func (m *DependencyGroup) Reset()      { *m = DependencyGroup{} }
func (*DependencyGroup) ProtoMessage() {}
func (*DependencyGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{8}
}
func (m *DependencyGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DependencyGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DependencyGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DependencyGroup.Merge(m, src)
}
func (m *DependencyGroup) XXX_Size() int {
	return m.Size()
}
func (m *DependencyGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DependencyGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DependencyGroup proto.InternalMessageInfo

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{9}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *EventContext) Reset()      { *m = EventContext{} }
func (*EventContext) ProtoMessage() {}
func (*EventContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{10}
}
func (m *EventContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventContext.Merge(m, src)
}
func (m *EventContext) XXX_Size() int {
	return m.Size()
}
func (m *EventContext) XXX_DiscardUnknown() {
	xxx_messageInfo_EventContext.DiscardUnknown(m)
}

var xxx_messageInfo_EventContext proto.InternalMessageInfo

func (m *EventDependency) Reset()      { *m = EventDependency{} }
func (*EventDependency) ProtoMessage() {}
func (*EventDependency) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{11}
}
func (m *EventDependency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDependency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventDependency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDependency.Merge(m, src)
}
func (m *EventDependency) XXX_Size() int {
	return m.Size()
}
func (m *EventDependency) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDependency.DiscardUnknown(m)
}

var xxx_messageInfo_EventDependency proto.InternalMessageInfo

func (m *EventDependencyFilter) Reset()      { *m = EventDependencyFilter{} }
func (*EventDependencyFilter) ProtoMessage() {}
func (*EventDependencyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{12}
}
func (m *EventDependencyFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDependencyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EventDependencyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDependencyFilter.Merge(m, src)
}
func (m *EventDependencyFilter) XXX_Size() int {
	return m.Size()
}
func (m *EventDependencyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDependencyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_EventDependencyFilter proto.InternalMessageInfo

func (m *FileArtifact) Reset()      { *m = FileArtifact{} }
func (*FileArtifact) ProtoMessage() {}
func (*FileArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{13}
}
func (m *FileArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FileArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileArtifact.Merge(m, src)
}
func (m *FileArtifact) XXX_Size() int {
	return m.Size()
}
func (m *FileArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_FileArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_FileArtifact proto.InternalMessageInfo

func (m *GitArtifact) Reset()      { *m = GitArtifact{} }
func (*GitArtifact) ProtoMessage() {}
func (*GitArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{14}
}
func (m *GitArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitArtifact.Merge(m, src)
}
func (m *GitArtifact) XXX_Size() int {
	return m.Size()
}
func (m *GitArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_GitArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_GitArtifact proto.InternalMessageInfo

func (m *GitCreds) Reset()      { *m = GitCreds{} }
func (*GitCreds) ProtoMessage() {}
func (*GitCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{15}
}
func (m *GitCreds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitCreds.Merge(m, src)
}
func (m *GitCreds) XXX_Size() int {
	return m.Size()
}
func (m *GitCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_GitCreds.DiscardUnknown(m)
}

var xxx_messageInfo_GitCreds proto.InternalMessageInfo

func (m *GitRemoteConfig) Reset()      { *m = GitRemoteConfig{} }
func (*GitRemoteConfig) ProtoMessage() {}
func (*GitRemoteConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{16}
}
func (m *GitRemoteConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitRemoteConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GitRemoteConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitRemoteConfig.Merge(m, src)
}
func (m *GitRemoteConfig) XXX_Size() int {
	return m.Size()
}
func (m *GitRemoteConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GitRemoteConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GitRemoteConfig proto.InternalMessageInfo

func (m *HTTPSubscription) Reset()      { *m = HTTPSubscription{} }
func (*HTTPSubscription) ProtoMessage() {}
func (*HTTPSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{17}
}
func (m *HTTPSubscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HTTPSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPSubscription.Merge(m, src)
}
func (m *HTTPSubscription) XXX_Size() int {
	return m.Size()
}
func (m *HTTPSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPSubscription proto.InternalMessageInfo

func (m *HTTPTrigger) Reset()      { *m = HTTPTrigger{} }
func (*HTTPTrigger) ProtoMessage() {}
func (*HTTPTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{18}
}
func (m *HTTPTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HTTPTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPTrigger.Merge(m, src)
}
func (m *HTTPTrigger) XXX_Size() int {
	return m.Size()
}
func (m *HTTPTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPTrigger proto.InternalMessageInfo

// K8sResourcePolicy refers to the policy used to check the state of K8s based triggers using using labels
type K8SResourcePolicy struct {
	// Labels required to identify whether a resource is in success state
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels" json:"labels" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Backoff before checking resource state
	Backoff Backoff `protobuf:"bytes,2,opt,name=backoff" json:"backoff"`
	// ErrorOnBackoffTimeout determines whether sensor should transition to error state if the trigger policy is unable to determine
	// the state of the resource
	ErrorOnBackoffTimeout bool     `protobuf:"varint,3,opt,name=errorOnBackoffTimeout" json:"errorOnBackoffTimeout"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *K8SResourcePolicy) Reset()      { *m = K8SResourcePolicy{} }
func (*K8SResourcePolicy) ProtoMessage() {}
func (*K8SResourcePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{19}
}
func (m *K8SResourcePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SResourcePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SResourcePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SResourcePolicy.Merge(m, src)
}
func (m *K8SResourcePolicy) XXX_Size() int {
	return m.Size()
}
func (m *K8SResourcePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SResourcePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_K8SResourcePolicy proto.InternalMessageInfo

func (m *KafkaTrigger) Reset()      { *m = KafkaTrigger{} }
func (*KafkaTrigger) ProtoMessage() {}
func (*KafkaTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{20}
}
func (m *KafkaTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KafkaTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KafkaTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KafkaTrigger.Merge(m, src)
}
func (m *KafkaTrigger) XXX_Size() int {
	return m.Size()
}
func (m *KafkaTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_KafkaTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_KafkaTrigger proto.InternalMessageInfo

func (m *NATSSubscription) Reset()      { *m = NATSSubscription{} }
func (*NATSSubscription) ProtoMessage() {}
func (*NATSSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{21}
}
func (m *NATSSubscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NATSSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NATSSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NATSSubscription.Merge(m, src)
}
func (m *NATSSubscription) XXX_Size() int {
	return m.Size()
}
func (m *NATSSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_NATSSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_NATSSubscription proto.InternalMessageInfo

func (m *NATSTrigger) Reset()      { *m = NATSTrigger{} }
func (*NATSTrigger) ProtoMessage() {}
func (*NATSTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{22}
}
func (m *NATSTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NATSTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NATSTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NATSTrigger.Merge(m, src)
}
func (m *NATSTrigger) XXX_Size() int {
	return m.Size()
}
func (m *NATSTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_NATSTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_NATSTrigger proto.InternalMessageInfo

func (m *NodeStatus) Reset()      { *m = NodeStatus{} }
func (*NodeStatus) ProtoMessage() {}
func (*NodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{23}
}
func (m *NodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeStatus.Merge(m, src)
}
func (m *NodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *NodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NodeStatus proto.InternalMessageInfo

func (m *OpenWhiskTrigger) Reset()      { *m = OpenWhiskTrigger{} }
func (*OpenWhiskTrigger) ProtoMessage() {}
func (*OpenWhiskTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{24}
}
func (m *OpenWhiskTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenWhiskTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OpenWhiskTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenWhiskTrigger.Merge(m, src)
}
func (m *OpenWhiskTrigger) XXX_Size() int {
	return m.Size()
}
func (m *OpenWhiskTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenWhiskTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_OpenWhiskTrigger proto.InternalMessageInfo

func (m *S3Artifact) Reset()      { *m = S3Artifact{} }
func (*S3Artifact) ProtoMessage() {}
func (*S3Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{25}
}
func (m *S3Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *S3Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Artifact.Merge(m, src)
}
func (m *S3Artifact) XXX_Size() int {
	return m.Size()
}
func (m *S3Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_S3Artifact proto.InternalMessageInfo

func (m *S3Bucket) Reset()      { *m = S3Bucket{} }
func (*S3Bucket) ProtoMessage() {}
func (*S3Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{26}
}
func (m *S3Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *S3Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Bucket.Merge(m, src)
}
func (m *S3Bucket) XXX_Size() int {
	return m.Size()
}
func (m *S3Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_S3Bucket proto.InternalMessageInfo

func (m *S3Filter) Reset()      { *m = S3Filter{} }
func (*S3Filter) ProtoMessage() {}
func (*S3Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{27}
}
func (m *S3Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *S3Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Filter.Merge(m, src)
}
func (m *S3Filter) XXX_Size() int {
	return m.Size()
}
func (m *S3Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Filter.DiscardUnknown(m)
}

var xxx_messageInfo_S3Filter proto.InternalMessageInfo

func (m *Sensor) Reset()      { *m = Sensor{} }
func (*Sensor) ProtoMessage() {}
func (*Sensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{28}
}
func (m *Sensor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sensor.Merge(m, src)
}
func (m *Sensor) XXX_Size() int {
	return m.Size()
}
func (m *Sensor) XXX_DiscardUnknown() {
	xxx_messageInfo_Sensor.DiscardUnknown(m)
}

var xxx_messageInfo_Sensor proto.InternalMessageInfo

func (m *SensorList) Reset()      { *m = SensorList{} }
func (*SensorList) ProtoMessage() {}
func (*SensorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{29}
}
func (m *SensorList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SensorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorList.Merge(m, src)
}
func (m *SensorList) XXX_Size() int {
	return m.Size()
}
func (m *SensorList) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorList.DiscardUnknown(m)
}

var xxx_messageInfo_SensorList proto.InternalMessageInfo

func (m *SensorResources) Reset()      { *m = SensorResources{} }
func (*SensorResources) ProtoMessage() {}
func (*SensorResources) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{30}
}
func (m *SensorResources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorResources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SensorResources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorResources.Merge(m, src)
}
func (m *SensorResources) XXX_Size() int {
	return m.Size()
}
func (m *SensorResources) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorResources.DiscardUnknown(m)
}

var xxx_messageInfo_SensorResources proto.InternalMessageInfo

func (m *SensorSpec) Reset()      { *m = SensorSpec{} }
func (*SensorSpec) ProtoMessage() {}
func (*SensorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{31}
}
func (m *SensorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SensorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorSpec.Merge(m, src)
}
func (m *SensorSpec) XXX_Size() int {
	return m.Size()
}
func (m *SensorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SensorSpec proto.InternalMessageInfo

func (m *SensorStatus) Reset()      { *m = SensorStatus{} }
func (*SensorStatus) ProtoMessage() {}
func (*SensorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{32}
}
func (m *SensorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SensorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorStatus.Merge(m, src)
}
func (m *SensorStatus) XXX_Size() int {
	return m.Size()
}
func (m *SensorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SensorStatus proto.InternalMessageInfo

func (m *SlackTrigger) Reset()      { *m = SlackTrigger{} }
func (*SlackTrigger) ProtoMessage() {}
func (*SlackTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{33}
}
func (m *SlackTrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlackTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SlackTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlackTrigger.Merge(m, src)
}
func (m *SlackTrigger) XXX_Size() int {
	return m.Size()
}
func (m *SlackTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_SlackTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_SlackTrigger proto.InternalMessageInfo

// StandardK8sTrigger is the standard Kubernetes resource trigger
type StandardK8STrigger struct {
	// The unambiguous kind of this object - used in order to retrieve the appropriate kubernetes api client for this resource
	GroupVersionResource *v11.GroupVersionResource `protobuf:"bytes,1,opt,name=groupVersionResource" json:"groupVersionResource,omitempty"`
	// Source of the K8 resource file(s)
	Source *ArtifactLocation `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	// Operation refers to the type of operation performed on the k8s resource.
	// Default value is Create.
	// +optional
	Operation KubernetesResourceOperation `protobuf:"bytes,3,opt,name=operation,casttype=KubernetesResourceOperation" json:"operation"`
	// Parameters is the list of parameters that is applied to resolved K8s trigger object.
	// +listType=triggerParameters
	Parameters []TriggerParameter `protobuf:"bytes,4,rep,name=parameters" json:"parameters"`
	// PatchStrategy controls the K8s object patching strategy when the trigger operation is specified as patch.
	// possible values:
	// "application/json-patch+json"
	// "application/merge-patch+json"
	// "application/strategic-merge-patch+json"
	// "application/apply-patch+yaml".
	// Defaults to "application/merge-patch+json"
	// +optional
	PatchStrategy k8s_io_apimachinery_pkg_types.PatchType `protobuf:"bytes,5,opt,name=patchStrategy,casttype=k8s.io/apimachinery/pkg/types.PatchType" json:"patchStrategy"`
	// LiveObject specifies whether the resource should be directly fetched from K8s instead
	// of being marshaled from the resource artifact. If set to true, the resource artifact
	// must contain the information required to uniquely identify the resource in the cluster,
	// that is, you must specify "apiVersion", "kind" as well as "name" and "namespace" meta
	// data.
	// Only valid for operation type `update`
	// +optional
	LiveObject           bool     `protobuf:"varint,6,opt,name=liveObject" json:"liveObject"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StandardK8STrigger) Reset()      { *m = StandardK8STrigger{} }
func (*StandardK8STrigger) ProtoMessage() {}
func (*StandardK8STrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{34}
}
func (m *StandardK8STrigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StandardK8STrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StandardK8STrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StandardK8STrigger.Merge(m, src)
}
func (m *StandardK8STrigger) XXX_Size() int {
	return m.Size()
}
func (m *StandardK8STrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_StandardK8STrigger.DiscardUnknown(m)
}

var xxx_messageInfo_StandardK8STrigger proto.InternalMessageInfo

func (m *StatusPolicy) Reset()      { *m = StatusPolicy{} }
func (*StatusPolicy) ProtoMessage() {}
func (*StatusPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{35}
}
func (m *StatusPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusPolicy.Merge(m, src)
}
func (m *StatusPolicy) XXX_Size() int {
	return m.Size()
}
func (m *StatusPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_StatusPolicy proto.InternalMessageInfo

func (m *Subscription) Reset()      { *m = Subscription{} }
func (*Subscription) ProtoMessage() {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{36}
}
func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(m, src)
}
func (m *Subscription) XXX_Size() int {
	return m.Size()
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *TLSConfig) Reset()      { *m = TLSConfig{} }
func (*TLSConfig) ProtoMessage() {}
func (*TLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{37}
}
func (m *TLSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSConfig.Merge(m, src)
}
func (m *TLSConfig) XXX_Size() int {
	return m.Size()
}
func (m *TLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TLSConfig proto.InternalMessageInfo

func (m *Template) Reset()      { *m = Template{} }
func (*Template) ProtoMessage() {}
func (*Template) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{38}
}
func (m *Template) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Template) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Template) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Template.Merge(m, src)
}
func (m *Template) XXX_Size() int {
	return m.Size()
}
func (m *Template) XXX_DiscardUnknown() {
	xxx_messageInfo_Template.DiscardUnknown(m)
}

var xxx_messageInfo_Template proto.InternalMessageInfo

func (m *TimeFilter) Reset()      { *m = TimeFilter{} }
func (*TimeFilter) ProtoMessage() {}
func (*TimeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{39}
}
func (m *TimeFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TimeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeFilter.Merge(m, src)
}
func (m *TimeFilter) XXX_Size() int {
	return m.Size()
}
func (m *TimeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_TimeFilter proto.InternalMessageInfo

func (m *Trigger) Reset()      { *m = Trigger{} }
func (*Trigger) ProtoMessage() {}
func (*Trigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{40}
}
func (m *Trigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Trigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trigger.Merge(m, src)
}
func (m *Trigger) XXX_Size() int {
	return m.Size()
}
func (m *Trigger) XXX_DiscardUnknown() {
	xxx_messageInfo_Trigger.DiscardUnknown(m)
}

var xxx_messageInfo_Trigger proto.InternalMessageInfo

func (m *TriggerParameter) Reset()      { *m = TriggerParameter{} }
func (*TriggerParameter) ProtoMessage() {}
func (*TriggerParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{41}
}
func (m *TriggerParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerParameter.Merge(m, src)
}
func (m *TriggerParameter) XXX_Size() int {
	return m.Size()
}
func (m *TriggerParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerParameter.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerParameter proto.InternalMessageInfo

func (m *TriggerParameterSource) Reset()      { *m = TriggerParameterSource{} }
func (*TriggerParameterSource) ProtoMessage() {}
func (*TriggerParameterSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{42}
}
func (m *TriggerParameterSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerParameterSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerParameterSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerParameterSource.Merge(m, src)
}
func (m *TriggerParameterSource) XXX_Size() int {
	return m.Size()
}
func (m *TriggerParameterSource) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerParameterSource.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerParameterSource proto.InternalMessageInfo

func (m *TriggerPolicy) Reset()      { *m = TriggerPolicy{} }
func (*TriggerPolicy) ProtoMessage() {}
func (*TriggerPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{43}
}
func (m *TriggerPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerPolicy.Merge(m, src)
}
func (m *TriggerPolicy) XXX_Size() int {
	return m.Size()
}
func (m *TriggerPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerPolicy proto.InternalMessageInfo

func (m *TriggerSwitch) Reset()      { *m = TriggerSwitch{} }
func (*TriggerSwitch) ProtoMessage() {}
func (*TriggerSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{44}
}
func (m *TriggerSwitch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerSwitch.Merge(m, src)
}
func (m *TriggerSwitch) XXX_Size() int {
	return m.Size()
}
func (m *TriggerSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerSwitch proto.InternalMessageInfo

func (m *TriggerTemplate) Reset()      { *m = TriggerTemplate{} }
func (*TriggerTemplate) ProtoMessage() {}
func (*TriggerTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{45}
}
func (m *TriggerTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TriggerTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerTemplate.Merge(m, src)
}
func (m *TriggerTemplate) XXX_Size() int {
	return m.Size()
}
func (m *TriggerTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerTemplate proto.InternalMessageInfo

func (m *URLArtifact) Reset()      { *m = URLArtifact{} }
func (*URLArtifact) ProtoMessage() {}
func (*URLArtifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c4bded897df1f16, []int{46}
}
func (m *URLArtifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLArtifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *URLArtifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLArtifact.Merge(m, src)
}
func (m *URLArtifact) XXX_Size() int {
	return m.Size()
}
func (m *URLArtifact) XXX_DiscardUnknown() {
	xxx_messageInfo_URLArtifact.DiscardUnknown(m)
}

var xxx_messageInfo_URLArtifact proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AWSLambdaTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.AWSLambdaTrigger")
	proto.RegisterType((*ArgoWorkflowTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.ArgoWorkflowTrigger")
	proto.RegisterType((*ArtifactLocation)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.ArtifactLocation")
	proto.RegisterType((*Backoff)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Backoff")
	proto.RegisterType((*BasicAuth)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.BasicAuth")
	proto.RegisterType((*ConfigmapArtifact)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.ConfigmapArtifact")
	proto.RegisterType((*CustomTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.CustomTrigger")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.CustomTrigger.SpecEntry")
	proto.RegisterType((*DataFilter)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.DataFilter")
	proto.RegisterType((*DependencyGroup)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.DependencyGroup")
	proto.RegisterType((*Event)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Event")
	proto.RegisterType((*EventContext)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.EventContext")
	proto.RegisterType((*EventDependency)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.EventDependency")
	proto.RegisterType((*EventDependencyFilter)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.EventDependencyFilter")
	proto.RegisterType((*FileArtifact)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.FileArtifact")
	proto.RegisterType((*GitArtifact)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.GitArtifact")
	proto.RegisterType((*GitCreds)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.GitCreds")
	proto.RegisterType((*GitRemoteConfig)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.GitRemoteConfig")
	proto.RegisterType((*HTTPSubscription)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.HTTPSubscription")
	proto.RegisterType((*HTTPTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.HTTPTrigger")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.HTTPTrigger.HeadersEntry")
	proto.RegisterType((*K8SResourcePolicy)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.K8sResourcePolicy")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.K8sResourcePolicy.LabelsEntry")
	proto.RegisterType((*KafkaTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.KafkaTrigger")
	proto.RegisterType((*NATSSubscription)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.NATSSubscription")
	proto.RegisterType((*NATSTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.NATSTrigger")
	proto.RegisterType((*NodeStatus)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.NodeStatus")
	proto.RegisterType((*OpenWhiskTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.OpenWhiskTrigger")
	proto.RegisterType((*S3Artifact)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.S3Artifact")
	proto.RegisterType((*S3Bucket)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.S3Bucket")
	proto.RegisterType((*S3Filter)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.S3Filter")
	proto.RegisterType((*Sensor)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Sensor")
	proto.RegisterType((*SensorList)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorList")
	proto.RegisterType((*SensorResources)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorResources")
	proto.RegisterType((*SensorSpec)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorSpec")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorSpec.ServiceAnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorSpec.ServiceLabelsEntry")
	proto.RegisterType((*SensorStatus)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorStatus")
	proto.RegisterMapType((map[string]NodeStatus)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SensorStatus.NodesEntry")
	proto.RegisterType((*SlackTrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.SlackTrigger")
	proto.RegisterType((*StandardK8STrigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.StandardK8sTrigger")
	proto.RegisterType((*StatusPolicy)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.StatusPolicy")
	proto.RegisterType((*Subscription)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Subscription")
	proto.RegisterType((*TLSConfig)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TLSConfig")
	proto.RegisterType((*Template)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Template")
	proto.RegisterType((*TimeFilter)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TimeFilter")
	proto.RegisterType((*Trigger)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.Trigger")
	proto.RegisterType((*TriggerParameter)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TriggerParameter")
	proto.RegisterType((*TriggerParameterSource)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TriggerParameterSource")
	proto.RegisterType((*TriggerPolicy)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TriggerPolicy")
	proto.RegisterType((*TriggerSwitch)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TriggerSwitch")
	proto.RegisterType((*TriggerTemplate)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.TriggerTemplate")
	proto.RegisterType((*URLArtifact)(nil), "github.com.argoproj.argo_events.pkg.apis.sensor.v1alpha1.URLArtifact")
}

func init() {
	proto.RegisterFile("github.com/argoproj/argo-events/pkg/apis/sensor/v1alpha1/generated.proto", fileDescriptor_6c4bded897df1f16)
}

var fileDescriptor_6c4bded897df1f16 = []byte{
	// 4281 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3c, 0x5d, 0x6f, 0x24, 0x49,
	0x52, 0xd3, 0x9f, 0xee, 0x0e, 0xb7, 0xd7, 0x9e, 0xdc, 0x9d, 0x3b, 0xaf, 0x6f, 0x77, 0x3c, 0xd4,
	0x89, 0x65, 0xee, 0xb4, 0xd7, 0xde, 0x9d, 0xdd, 0x83, 0xb9, 0x45, 0xc0, 0xba, 0xdb, 0x9e, 0x2f,
	0x7b, 0x66, 0x7c, 0xd9, 0x9e, 0x1d, 0x69, 0x59, 0x71, 0x93, 0xae, 0xce, 0xee, 0xae, 0x71, 0x75,
	0x55, 0x51, 0x99, 0xed, 0xd9, 0x96, 0xe0, 0x40, 0x5a, 0x21, 0x21, 0x81, 0x74, 0xc0, 0xdd, 0x8f,
	0xe0, 0xe1, 0x74, 0xef, 0x48, 0x20, 0x24, 0x04, 0x62, 0x1f, 0x78, 0x38, 0x1e, 0x90, 0xee, 0xc9,
	0x62, 0x7d, 0x0f, 0x3c, 0x80, 0xc4, 0x0b, 0x4f, 0x83, 0x04, 0x28, 0xbf, 0xaa, 0xb2, 0xca, 0x3d,
	0x33, 0xb6, 0x6b, 0xd6, 0x20, 0xf1, 0x56, 0x1d, 0x11, 0x19, 0x91, 0x19, 0x19, 0x19, 0x19, 0x11,
	0x99, 0xd9, 0x70, 0x6b, 0xe8, 0xf1, 0xd1, 0x64, 0xaf, 0xed, 0x86, 0xe3, 0x35, 0x12, 0x0f, 0xc3,
	0x28, 0x0e, 0x1f, 0xcb, 0x8f, 0x6f, 0xd1, 0x03, 0x1a, 0x70, 0xb6, 0x16, 0xed, 0x0f, 0xd7, 0x48,
	0xe4, 0xb1, 0x35, 0x46, 0x03, 0x16, 0xc6, 0x6b, 0x07, 0xef, 0x12, 0x3f, 0x1a, 0x91, 0x77, 0xd7,
	0x86, 0x34, 0xa0, 0x31, 0xe1, 0xb4, 0xdf, 0x8e, 0xe2, 0x90, 0x87, 0xe8, 0x7a, 0xca, 0xa9, 0x6d,
	0x38, 0xc9, 0x8f, 0xef, 0x29, 0x4e, 0xed, 0x68, 0x7f, 0xd8, 0x16, 0x9c, 0xda, 0x8a, 0x53, 0xdb,
	0x70, 0x5a, 0xf9, 0x96, 0xd5, 0x87, 0x61, 0x38, 0x0c, 0xd7, 0x24, 0xc3, 0xbd, 0xc9, 0x40, 0xfe,
	0x92, 0x3f, 0xe4, 0x97, 0x12, 0xb4, 0xe2, 0xec, 0x5f, 0x67, 0x6d, 0x2f, 0x14, 0xbd, 0x5a, 0x73,
	0xc3, 0x98, 0xae, 0x1d, 0x1c, 0xeb, 0xcc, 0xca, 0xfb, 0x29, 0xcd, 0x98, 0xb8, 0x23, 0x2f, 0xa0,
	0xf1, 0x34, 0x1d, 0xca, 0x98, 0x72, 0x32, 0xab, 0xd5, 0xda, 0xb3, 0x5a, 0xc5, 0x93, 0x80, 0x7b,
	0x63, 0x7a, 0xac, 0xc1, 0x2f, 0xbf, 0xa8, 0x01, 0x73, 0x47, 0x74, 0x4c, 0xf2, 0xed, 0x9c, 0xbf,
	0xad, 0xc2, 0xd2, 0xfa, 0xc3, 0xde, 0x36, 0x19, 0xef, 0xf5, 0xc9, 0x6e, 0xec, 0x0d, 0x87, 0x34,
	0x46, 0xd7, 0xa1, 0x35, 0x98, 0x04, 0x2e, 0xf7, 0xc2, 0xe0, 0x1e, 0x19, 0xd3, 0xe5, 0xd2, 0x95,
	0xd2, 0xd5, 0x66, 0xe7, 0xb5, 0xcf, 0x0f, 0x57, 0x2f, 0x1c, 0x1d, 0xae, 0xb6, 0x6e, 0x58, 0x38,
	0x9c, 0xa1, 0x44, 0x18, 0x9a, 0xc4, 0x75, 0x29, 0x63, 0x5b, 0x74, 0xba, 0x5c, 0xbe, 0x52, 0xba,
	0x3a, 0x7f, 0xed, 0x17, 0xdb, 0xaa, 0x6b, 0x42, 0xe3, 0x6d, 0xa1, 0xa5, 0xf6, 0xc1, 0xbb, 0xed,
	0x1e, 0x75, 0x63, 0xca, 0xb7, 0xe8, 0xb4, 0x47, 0x7d, 0xea, 0xf2, 0x30, 0xee, 0x2c, 0x1c, 0x1d,
	0xae, 0x36, 0xd7, 0x4d, 0x5b, 0x9c, 0xb2, 0x11, 0x3c, 0x99, 0x21, 0x5f, 0xae, 0x9c, 0x9a, 0x67,
	0x02, 0xc6, 0x29, 0x1b, 0xb4, 0x06, 0xcd, 0x80, 0x8c, 0x29, 0x8b, 0x88, 0x4b, 0x97, 0xab, 0x72,
	0x78, 0x17, 0xf5, 0xf0, 0x9a, 0xf7, 0x0c, 0x02, 0xa7, 0x34, 0xe8, 0x2d, 0xa8, 0xc7, 0x74, 0xe8,
	0x85, 0xc1, 0x72, 0x4d, 0x52, 0xbf, 0xa2, 0xa9, 0xeb, 0x58, 0x42, 0xb1, 0xc6, 0xa2, 0x09, 0xcc,
	0x45, 0x64, 0xea, 0x87, 0xa4, 0xbf, 0x5c, 0xbf, 0x52, 0xb9, 0x3a, 0x7f, 0xed, 0x4e, 0xfb, 0xac,
	0xd6, 0xd8, 0xd6, 0xd3, 0xb1, 0x43, 0x62, 0x32, 0xa6, 0x9c, 0xc6, 0x9d, 0x45, 0x2d, 0x74, 0x6e,
	0x47, 0x89, 0xc0, 0x46, 0x16, 0xfa, 0x3e, 0x40, 0x64, 0xc8, 0xd8, 0xf2, 0xdc, 0x4b, 0x97, 0x8c,
	0xb4, 0x64, 0x48, 0x40, 0x0c, 0x5b, 0x12, 0x9d, 0xc3, 0x0a, 0xbc, 0xba, 0x1e, 0x0f, 0xc3, 0x87,
	0x61, 0xbc, 0x3f, 0xf0, 0xc3, 0x27, 0xc6, 0x92, 0x02, 0xa8, 0xb3, 0x70, 0x12, 0xbb, 0xca, 0x86,
	0x0a, 0xf5, 0x69, 0x3d, 0xe6, 0xde, 0x80, 0xb8, 0x7c, 0x3b, 0x74, 0x89, 0xb0, 0xb7, 0x0e, 0x08,
	0xf5, 0xf7, 0x24, 0x77, 0xac, 0xa5, 0xa0, 0x5b, 0xd0, 0x0c, 0x23, 0x61, 0xe0, 0x62, 0xa6, 0xca,
	0x72, 0xa6, 0xbe, 0x69, 0xe6, 0xf5, 0xbe, 0x41, 0x3c, 0x3d, 0x5c, 0xbd, 0x64, 0x77, 0x36, 0x41,
	0xe0, 0xb4, 0x71, 0x4e, 0xa3, 0x95, 0xf3, 0xd6, 0x28, 0xfa, 0xe3, 0x12, 0xbc, 0x36, 0x8c, 0xc3,
	0x49, 0xf4, 0x11, 0x8d, 0x99, 0xe8, 0x1b, 0xd5, 0x8a, 0xac, 0x4a, 0x45, 0x7e, 0x60, 0xad, 0x80,
	0x64, 0xc1, 0xa7, 0xe2, 0x85, 0x5f, 0x11, 0x6b, 0xe2, 0xe6, 0x0c, 0x0e, 0x9d, 0x37, 0xb4, 0xe8,
	0xd7, 0x66, 0x61, 0xf1, 0x4c, 0xa9, 0xce, 0x7f, 0x09, 0x3f, 0x91, 0x9b, 0x01, 0xf4, 0x09, 0x94,
	0xd9, 0x7b, 0x7a, 0x66, 0x37, 0xce, 0xae, 0x9b, 0xde, 0x7b, 0x86, 0x73, 0xa7, 0x7e, 0x74, 0xb8,
	0x5a, 0xee, 0xbd, 0x87, 0xcb, 0xec, 0x3d, 0xe4, 0x40, 0xdd, 0x0b, 0x7c, 0x2f, 0xa0, 0x7a, 0x22,
	0xe5, 0x7c, 0xdf, 0x96, 0x10, 0xac, 0x31, 0xa8, 0x0f, 0xd5, 0x81, 0xe7, 0x53, 0xed, 0x16, 0x6e,
	0x9c, 0xbd, 0x0f, 0x37, 0x3c, 0x9f, 0x26, 0xbd, 0x68, 0x1c, 0x1d, 0xae, 0x56, 0x05, 0x04, 0x4b,
	0xee, 0xe8, 0x11, 0x54, 0x26, 0xb1, 0xaf, 0x35, 0xbf, 0x79, 0x76, 0x21, 0x0f, 0xf0, 0x76, 0x22,
	0x63, 0xee, 0xe8, 0x70, 0xb5, 0xf2, 0x00, 0x6f, 0x63, 0xc1, 0x1a, 0x7d, 0x0a, 0x4d, 0x37, 0x0c,
	0x06, 0xde, 0x70, 0x4c, 0x22, 0xe9, 0x61, 0xe6, 0xaf, 0x6d, 0x9d, 0x5d, 0x4e, 0xd7, 0xb0, 0x4a,
	0xa4, 0x49, 0x4f, 0x98, 0x80, 0x71, 0x2a, 0x4c, 0x8c, 0x6d, 0xe8, 0xf1, 0xe5, 0x7a, 0xd1, 0xb1,
	0xdd, 0xf4, 0x78, 0x76, 0x6c, 0x37, 0x3d, 0x8e, 0x05, 0x6b, 0xb4, 0x01, 0x8d, 0xd8, 0x18, 0xef,
	0xdc, 0x95, 0xd2, 0xd5, 0x56, 0xe7, 0xea, 0xd1, 0xe1, 0x6a, 0xc3, 0x98, 0xd6, 0xd3, 0xc3, 0xd5,
	0x65, 0x1a, 0xb8, 0x61, 0xdf, 0x0b, 0x86, 0x6b, 0x8f, 0x59, 0x18, 0xb4, 0x31, 0x79, 0x72, 0x97,
	0x32, 0x46, 0x86, 0x14, 0x27, 0x2d, 0x9d, 0xbf, 0x2a, 0xc1, 0x5c, 0x87, 0xb8, 0xfb, 0xe1, 0x60,
	0x80, 0x7e, 0x0d, 0x1a, 0xfd, 0x89, 0x5e, 0xe4, 0xc2, 0xfa, 0x2a, 0x9d, 0x5f, 0xd0, 0x26, 0xdd,
	0xd8, 0x98, 0x24, 0x6b, 0x7c, 0x41, 0xec, 0x7b, 0x6d, 0x03, 0xc0, 0x49, 0x13, 0xe1, 0xcb, 0x45,
	0x37, 0xc3, 0x58, 0x1a, 0x56, 0x29, 0xf5, 0xe5, 0x37, 0x24, 0x14, 0x6b, 0xac, 0xa0, 0x7b, 0xec,
	0x71, 0x4e, 0x63, 0x69, 0x5e, 0x16, 0xdd, 0x1d, 0x09, 0xc5, 0x1a, 0x8b, 0xbe, 0x0e, 0x35, 0xc6,
	0x69, 0xc4, 0xa4, 0x81, 0x54, 0x3a, 0x0b, 0x9a, 0xac, 0xd6, 0x13, 0x40, 0xac, 0x70, 0xce, 0x61,
	0x09, 0x9a, 0x1d, 0xc2, 0x3c, 0x77, 0x7d, 0xc2, 0x47, 0xe8, 0x3e, 0x34, 0x26, 0x8c, 0xc6, 0x81,
	0xd9, 0x5d, 0x4f, 0xbc, 0xa5, 0xb5, 0xc4, 0x20, 0x1f, 0xe8, 0xa6, 0x38, 0x61, 0x22, 0x18, 0x46,
	0x84, 0xb1, 0x27, 0x61, 0xdc, 0x3f, 0xdd, 0xbe, 0x2b, 0x19, 0xee, 0xe8, 0xa6, 0x38, 0x61, 0x92,
	0xdd, 0x21, 0x9b, 0x2f, 0xde, 0x21, 0x9d, 0x3f, 0x28, 0xc1, 0xc5, 0x63, 0x86, 0x87, 0xae, 0x40,
	0x35, 0x48, 0x43, 0x88, 0x96, 0xe6, 0x50, 0x95, 0xa1, 0x83, 0xc4, 0x64, 0x05, 0x95, 0x4f, 0xb0,
	0x15, 0xbf, 0x09, 0x95, 0x7d, 0x1d, 0x09, 0x34, 0x3b, 0xf3, 0x9a, 0xb4, 0x22, 0x36, 0x78, 0x01,
	0x77, 0x7e, 0x58, 0x83, 0x85, 0xee, 0x84, 0xf1, 0x70, 0x6c, 0x36, 0xa1, 0x35, 0x11, 0x40, 0xc4,
	0x07, 0x34, 0x7e, 0x80, 0xb7, 0x75, 0x47, 0x12, 0x09, 0x3d, 0x83, 0xc0, 0x29, 0x8d, 0x98, 0x78,
	0x46, 0xdd, 0x49, 0xac, 0xfa, 0xd3, 0x48, 0x27, 0xbe, 0x27, 0xa1, 0x58, 0x63, 0x45, 0x9c, 0xe4,
	0xd2, 0x98, 0x0b, 0x4f, 0xb1, 0x43, 0xf8, 0x48, 0x77, 0x29, 0x89, 0x93, 0xba, 0x16, 0x0e, 0x67,
	0x28, 0xd1, 0x1d, 0x40, 0x4a, 0x9c, 0x18, 0xe1, 0xfd, 0x03, 0x1a, 0xc7, 0x5e, 0xdf, 0x04, 0x22,
	0x2b, 0xba, 0x3d, 0xea, 0x1d, 0xa3, 0xc0, 0x33, 0x5a, 0x21, 0x06, 0x55, 0x16, 0x51, 0x77, 0xb9,
	0x26, 0xf7, 0xa8, 0xef, 0x16, 0x70, 0x1b, 0xb6, 0xd6, 0xda, 0xbd, 0x88, 0xba, 0x9b, 0x01, 0x8f,
	0xa7, 0xe9, 0xac, 0x09, 0x10, 0x96, 0xc2, 0x72, 0xdb, 0x63, 0xfd, 0xdc, 0xb7, 0x47, 0x2b, 0xce,
	0x9a, 0x3b, 0xbf, 0x38, 0x6b, 0xe5, 0x57, 0xa0, 0x99, 0xe8, 0x05, 0x2d, 0x29, 0x43, 0x94, 0x16,
	0x25, 0x6d, 0x0f, 0xbd, 0x06, 0xb5, 0x03, 0xe2, 0x4f, 0xb4, 0x1d, 0x63, 0xf5, 0xe3, 0x83, 0xf2,
	0xf5, 0x92, 0xf3, 0xd7, 0x25, 0x80, 0x0d, 0xc2, 0xc9, 0x0d, 0xcf, 0x17, 0x2e, 0xe3, 0x0a, 0x54,
	0x23, 0x61, 0x31, 0xb9, 0x65, 0x21, 0x2d, 0x45, 0x62, 0xd0, 0xdb, 0x50, 0xe5, 0xd3, 0xc8, 0xac,
	0x88, 0x65, 0x43, 0xb1, 0x3b, 0x8d, 0x84, 0xc7, 0x6c, 0xdc, 0xe9, 0xdd, 0xbf, 0x27, 0xbe, 0xb1,
	0xa4, 0x42, 0xab, 0x46, 0xb0, 0x08, 0x54, 0x9a, 0x9d, 0xa6, 0x70, 0x3f, 0x1f, 0x09, 0x80, 0xee,
	0x03, 0xfa, 0x10, 0xc0, 0x0d, 0xc7, 0x42, 0x81, 0xc2, 0xef, 0x29, 0x43, 0xbb, 0x62, 0x74, 0xdc,
	0x4d, 0x30, 0x4f, 0x33, 0xbf, 0xb0, 0xd5, 0xc6, 0xf1, 0x60, 0x71, 0x83, 0x46, 0x34, 0xe8, 0xd3,
	0xc0, 0x9d, 0xca, 0xc8, 0xe1, 0x04, 0x8b, 0xfb, 0x7d, 0x68, 0xf5, 0x4d, 0x23, 0x8f, 0xb2, 0xe5,
	0xb2, 0xec, 0xde, 0x92, 0x58, 0x1d, 0x1b, 0x16, 0x1c, 0x67, 0xa8, 0x9c, 0x1f, 0x95, 0xa0, 0xb6,
	0x29, 0x26, 0x0d, 0x8d, 0x61, 0xce, 0x0d, 0x03, 0x4e, 0x3f, 0xe5, 0xda, 0x4d, 0x16, 0xd8, 0xe2,
	0x25, 0xc7, 0xae, 0xe2, 0xd6, 0x99, 0x17, 0xd3, 0xab, 0x7f, 0x60, 0x23, 0x03, 0xbd, 0x01, 0xd5,
	0x3e, 0xe1, 0x44, 0x2a, 0xbd, 0xa5, 0xc2, 0x00, 0x31, 0x69, 0x58, 0x42, 0x9d, 0x7f, 0x29, 0x43,
	0xcb, 0x66, 0x82, 0x56, 0xa0, 0xec, 0xf5, 0xf5, 0xe8, 0x41, 0x8f, 0xbe, 0x7c, 0x7b, 0x03, 0x97,
	0xbd, 0xbe, 0xf4, 0x21, 0x6a, 0xcf, 0x2b, 0x67, 0x13, 0x86, 0x5c, 0xc4, 0xfa, 0x6d, 0x98, 0x17,
	0x0b, 0xea, 0x40, 0xc5, 0x5b, 0xda, 0x85, 0xbc, 0xaa, 0x89, 0xe7, 0x85, 0xb1, 0x99, 0x50, 0xcc,
	0xa6, 0x13, 0xaa, 0x97, 0xe6, 0x51, 0xcd, 0xaa, 0xde, 0x32, 0x89, 0x75, 0x58, 0x14, 0xbd, 0x96,
	0x7d, 0x0d, 0xb8, 0x40, 0xe8, 0xd4, 0xe5, 0xab, 0x9a, 0x78, 0x71, 0x23, 0x8b, 0xc6, 0x79, 0x7a,
	0xf4, 0x0d, 0x98, 0x63, 0x93, 0xbd, 0xc7, 0xd4, 0x55, 0xf1, 0x41, 0x33, 0x5d, 0x18, 0x3d, 0x05,
	0xc6, 0x06, 0x8f, 0xb6, 0xa1, 0x2a, 0xb6, 0x5b, 0xb9, 0xc1, 0xcf, 0x5f, 0xfb, 0xe6, 0xc9, 0xa2,
	0xd3, 0x5d, 0x6f, 0x4c, 0xad, 0xbe, 0x7b, 0xc2, 0x6c, 0x04, 0x17, 0xe7, 0x87, 0x65, 0x58, 0x94,
	0x9a, 0x4e, 0x2d, 0xee, 0x04, 0xc6, 0xf6, 0x6d, 0x98, 0x1f, 0x12, 0x4e, 0x9f, 0x90, 0xa9, 0xcc,
	0x5a, 0xcb, 0x59, 0x55, 0xde, 0x4c, 0x51, 0xd8, 0xa6, 0x13, 0xdb, 0x83, 0x34, 0x1d, 0xd9, 0xa8,
	0x92, 0xdd, 0x1e, 0x36, 0x0d, 0x02, 0xa7, 0x34, 0xe8, 0x00, 0xe6, 0x06, 0x72, 0x19, 0x33, 0x1d,
	0x12, 0xde, 0x2f, 0x68, 0x94, 0xe9, 0x28, 0x95, 0x7b, 0x50, 0xd6, 0xa9, 0xbe, 0x19, 0x36, 0xc2,
	0x9c, 0xff, 0x28, 0xc3, 0xa5, 0x99, 0xf4, 0x27, 0xd0, 0xcd, 0x9e, 0x9e, 0x9f, 0x72, 0xd1, 0x60,
	0x5d, 0xcc, 0x92, 0xee, 0x65, 0x23, 0x3b, 0x6b, 0xf6, 0x62, 0xad, 0x9c, 0xc3, 0x62, 0x1d, 0xe8,
	0xc5, 0x5a, 0x95, 0xfe, 0xbf, 0xc0, 0x90, 0x52, 0xbf, 0x9c, 0xaa, 0xce, 0x5a, 0xf6, 0xef, 0x40,
	0xcb, 0xce, 0x0e, 0x5e, 0xec, 0xbb, 0x9d, 0xbf, 0xa8, 0xc2, 0xbc, 0x15, 0x0f, 0x8b, 0x88, 0x45,
	0xe4, 0x0f, 0xa5, 0x6c, 0xc4, 0x92, 0x04, 0xff, 0xbf, 0x0e, 0xaf, 0xb8, 0x7e, 0x18, 0xd0, 0x0d,
	0x2f, 0x96, 0x31, 0xd9, 0x54, 0x9b, 0xee, 0x57, 0x34, 0xe5, 0x2b, 0xdd, 0x0c, 0x16, 0xe7, 0xa8,
	0x91, 0x0b, 0x35, 0x37, 0xa6, 0x7d, 0xa6, 0xb5, 0xde, 0x29, 0x14, 0xc4, 0x77, 0x05, 0x27, 0xb5,
	0x81, 0xc8, 0x4f, 0xac, 0x78, 0x9f, 0xbe, 0x62, 0x72, 0x0d, 0x80, 0xb1, 0xd1, 0x16, 0x9d, 0xca,
	0xd0, 0x48, 0xb9, 0x9e, 0x64, 0x57, 0xef, 0xf5, 0x6e, 0x69, 0x0c, 0xb6, 0xa8, 0xd0, 0xdb, 0xd0,
	0x18, 0x98, 0x60, 0x4a, 0x79, 0x9c, 0x25, 0x13, 0xd8, 0x27, 0x81, 0x54, 0x42, 0x21, 0x5c, 0xec,
	0x5e, 0x4c, 0x02, 0x77, 0x24, 0xbd, 0x8e, 0xe5, 0x62, 0x3b, 0x12, 0x8a, 0x35, 0x56, 0xa8, 0x9f,
	0x93, 0xe1, 0x72, 0x23, 0xab, 0xfe, 0x5d, 0x32, 0xc4, 0x02, 0x2e, 0xd0, 0x31, 0x1d, 0xe8, 0x18,
	0x37, 0x41, 0x63, 0x3a, 0xc0, 0x02, 0x8e, 0xc6, 0x50, 0x8f, 0xe9, 0x38, 0xe4, 0x74, 0x19, 0xa4,
	0x7a, 0x6f, 0x17, 0x52, 0x2f, 0x96, 0xac, 0x54, 0x9c, 0xac, 0x32, 0x5a, 0x05, 0xc1, 0x5a, 0x88,
	0xf3, 0xe3, 0x12, 0x34, 0xcc, 0x34, 0xfc, 0xdf, 0x4f, 0x13, 0x9c, 0xef, 0xc2, 0x62, 0x6e, 0x54,
	0x27, 0x70, 0x46, 0x6f, 0x40, 0x75, 0x12, 0xfb, 0x26, 0x1a, 0x90, 0x6e, 0xe4, 0x01, 0xde, 0xee,
	0x61, 0x09, 0x75, 0xde, 0x87, 0xa5, 0x5b, 0xbb, 0xbb, 0x3b, 0xbd, 0xc9, 0x1e, 0x73, 0x63, 0x2f,
	0xe2, 0x7a, 0xbb, 0x8b, 0xc2, 0x58, 0x05, 0x01, 0x35, 0x6b, 0xcd, 0x85, 0x31, 0xc7, 0x12, 0xe3,
	0x7c, 0x56, 0x87, 0x79, 0xd1, 0xcc, 0x04, 0xfd, 0x2f, 0x58, 0x73, 0x56, 0xfc, 0x58, 0x3e, 0xc7,
	0x3a, 0xdd, 0x6f, 0x41, 0x85, 0xfb, 0x66, 0xa1, 0x76, 0x0b, 0x88, 0xdc, 0xee, 0x69, 0x1b, 0x92,
	0xb9, 0xf6, 0xee, 0x76, 0x0f, 0x0b, 0xc6, 0x62, 0x49, 0x8c, 0x29, 0x1f, 0x85, 0x7d, 0xbd, 0x44,
	0x93, 0x25, 0x71, 0x57, 0x42, 0xb1, 0xc6, 0xe6, 0xc2, 0xf7, 0xda, 0xb9, 0x87, 0xef, 0xdf, 0x80,
	0x39, 0xb1, 0x65, 0x84, 0x13, 0x15, 0x59, 0x54, 0x52, 0x95, 0xed, 0x2a, 0x30, 0x36, 0x78, 0x14,
	0x41, 0x73, 0xcf, 0xe4, 0xcd, 0x3a, 0xbc, 0x28, 0xa0, 0xb8, 0x24, 0x05, 0x57, 0x25, 0x91, 0xe4,
	0x27, 0x4e, 0x85, 0xa0, 0xdf, 0x85, 0xb9, 0x11, 0x25, 0x7d, 0xa1, 0x99, 0x86, 0xd4, 0x0c, 0x3e,
	0xbb, 0x3c, 0xcb, 0x24, 0xdb, 0xb7, 0x14, 0x53, 0x95, 0x54, 0x25, 0x03, 0xd6, 0x50, 0x6c, 0x64,
	0xae, 0x7c, 0x00, 0x2d, 0x9b, 0xf2, 0x54, 0x69, 0xc6, 0x9f, 0x55, 0xe0, 0xe2, 0xd6, 0x75, 0x66,
	0x6a, 0x2b, 0x3b, 0xa1, 0xef, 0xb9, 0x53, 0xf4, 0x7b, 0x50, 0xf7, 0xc9, 0x1e, 0xf5, 0xd9, 0x72,
	0x49, 0x8e, 0xe7, 0xe1, 0xd9, 0xc7, 0x73, 0x8c, 0x79, 0x7b, 0x5b, 0x72, 0x56, 0x83, 0x4a, 0xcc,
	0x4d, 0x01, 0xb1, 0x16, 0x8b, 0x7c, 0x98, 0xdb, 0x53, 0xb5, 0x1b, 0xed, 0x75, 0xd6, 0x8b, 0xcc,
	0xa0, 0x64, 0x94, 0x2a, 0x50, 0x03, 0xb0, 0x11, 0x81, 0x7a, 0x70, 0x89, 0xc6, 0x71, 0x18, 0xdf,
	0x0f, 0x34, 0x4a, 0xdb, 0x94, 0x5c, 0x76, 0x8d, 0xce, 0x9b, 0xba, 0xe1, 0xa5, 0xcd, 0x59, 0x44,
	0x78, 0x76, 0xdb, 0x95, 0xef, 0xc0, 0xbc, 0x35, 0xd2, 0x53, 0x4d, 0xca, 0xdf, 0xd5, 0xa0, 0xb5,
	0x45, 0x06, 0xfb, 0xe4, 0x84, 0xbe, 0xe9, 0xeb, 0x50, 0xe3, 0x61, 0xe4, 0xb9, 0x3a, 0x0c, 0x48,
	0xea, 0x49, 0xbb, 0x02, 0x88, 0x15, 0x4e, 0xec, 0xc7, 0x11, 0x89, 0xb9, 0xc7, 0x4d, 0xd6, 0x50,
	0x49, 0xf7, 0xe3, 0x1d, 0x83, 0xc0, 0x29, 0x4d, 0x6e, 0xc9, 0x57, 0xcf, 0x7d, 0xc9, 0x5f, 0x87,
	0x56, 0x4c, 0x7f, 0x7b, 0xe2, 0xc5, 0xb4, 0xbf, 0xee, 0xee, 0x33, 0x19, 0x11, 0x54, 0xd2, 0x62,
	0x09, 0xb6, 0x70, 0x38, 0x43, 0x29, 0xa2, 0x02, 0x91, 0x87, 0xc6, 0x94, 0x31, 0xe9, 0x2d, 0x1a,
	0x69, 0x54, 0xd0, 0xd5, 0x70, 0x9c, 0x50, 0x88, 0x68, 0x6a, 0xe0, 0x4f, 0xd8, 0xe8, 0x86, 0xe0,
	0x21, 0x62, 0x64, 0xe9, 0x34, 0x2a, 0x69, 0x34, 0x75, 0x23, 0x83, 0xc5, 0x39, 0x6a, 0xe3, 0xa2,
	0x1b, 0x5f, 0x96, 0x8b, 0xb6, 0x76, 0x9e, 0xe6, 0x39, 0xee, 0x3c, 0xeb, 0xb0, 0x98, 0xd8, 0x82,
	0x17, 0x0c, 0xb7, 0xe8, 0x54, 0xc6, 0x33, 0x56, 0x3a, 0xb8, 0x93, 0x45, 0xe3, 0x3c, 0xbd, 0x13,
	0xc0, 0xd2, 0xbd, 0xf5, 0xdd, 0x5e, 0x66, 0x63, 0x3e, 0x75, 0x6d, 0xcd, 0xca, 0x29, 0xcb, 0xcf,
	0xcf, 0x29, 0x9d, 0x9f, 0x54, 0x60, 0x5e, 0x08, 0x3c, 0xe1, 0xb2, 0x39, 0x39, 0x67, 0x7b, 0x0e,
	0x2a, 0xff, 0x6b, 0xa7, 0x74, 0xe7, 0xbf, 0x04, 0xb5, 0x69, 0xd7, 0xbe, 0x24, 0xd3, 0x76, 0xfe,
	0xbb, 0x06, 0x70, 0x2f, 0xec, 0xd3, 0x1e, 0x27, 0x7c, 0xc2, 0x9e, 0x5b, 0x1e, 0x31, 0x41, 0x62,
	0xf9, 0x79, 0xd9, 0x7c, 0xdf, 0x63, 0x91, 0xaf, 0xb3, 0xf9, 0x5c, 0x61, 0x64, 0x23, 0x45, 0x61,
	0x9b, 0x2e, 0xa9, 0x9b, 0x55, 0x67, 0xd7, 0xcd, 0x44, 0xf7, 0xac, 0x22, 0xc9, 0x3b, 0x50, 0x8b,
	0x46, 0x84, 0x99, 0xd2, 0x88, 0x29, 0xbd, 0xd6, 0x76, 0x04, 0xf0, 0xa9, 0x48, 0x6d, 0xc2, 0x3e,
	0x95, 0x3f, 0xb0, 0x22, 0x44, 0x8f, 0xa0, 0xc9, 0x38, 0x89, 0x39, 0xed, 0xaf, 0x9b, 0x53, 0x93,
	0xb5, 0x93, 0x55, 0x3b, 0xee, 0x7a, 0x6e, 0x1c, 0xca, 0x92, 0x47, 0xba, 0x42, 0x0c, 0x27, 0x9c,
	0x32, 0x45, 0x03, 0x98, 0x17, 0xce, 0xcc, 0xa7, 0x4a, 0xc6, 0xdc, 0xd9, 0x64, 0x24, 0x9a, 0xea,
	0xa6, 0xbc, 0xb0, 0xcd, 0x58, 0xac, 0x97, 0xb1, 0x3a, 0x66, 0xd1, 0xa9, 0x51, 0x62, 0xb8, 0xe6,
	0xf4, 0xc5, 0xe0, 0xd1, 0x23, 0xa8, 0x49, 0x9b, 0x90, 0x49, 0xd2, 0xfc, 0xb5, 0xdf, 0x28, 0x98,
	0xd7, 0xab, 0xf4, 0x52, 0x7e, 0x62, 0xc5, 0x58, 0xa8, 0x75, 0x12, 0xf5, 0x89, 0x1a, 0x32, 0x14,
	0x54, 0xeb, 0x03, 0xc3, 0x09, 0xa7, 0x4c, 0x91, 0x0b, 0x10, 0x53, 0x16, 0xfa, 0x07, 0x52, 0xc4,
	0xfc, 0xd9, 0x44, 0x24, 0x2b, 0x0c, 0x27, 0xac, 0xb0, 0xc5, 0xd6, 0xf9, 0x41, 0x15, 0x96, 0xee,
	0x47, 0x34, 0x78, 0x38, 0xf2, 0xd8, 0xbe, 0xf1, 0x5b, 0x57, 0xa0, 0x3a, 0x0a, 0x19, 0xcf, 0x27,
	0x44, 0xb7, 0x42, 0xc6, 0xb1, 0xc4, 0x88, 0xa9, 0x30, 0x05, 0xc0, 0x9c, 0xeb, 0x32, 0xc5, 0x3f,
	0x83, 0xcf, 0xe6, 0xe1, 0x95, 0x13, 0xe4, 0xe1, 0x18, 0x9a, 0x64, 0xc2, 0x47, 0xbb, 0xe1, 0x3e,
	0x0d, 0x74, 0xbd, 0xea, 0x54, 0x57, 0x32, 0x4c, 0x5b, 0x9c, 0xb2, 0x11, 0xb9, 0x3d, 0x49, 0xaf,
	0x87, 0xe4, 0x72, 0xfb, 0xf5, 0xf4, 0x72, 0x88, 0x45, 0xf5, 0xff, 0xf5, 0x66, 0xc4, 0x8f, 0xab,
	0x00, 0xe9, 0x01, 0xb7, 0x88, 0x65, 0x68, 0xd0, 0x8f, 0x42, 0x2f, 0x30, 0xf6, 0x90, 0xc4, 0x32,
	0x9b, 0x1a, 0x8e, 0x13, 0x0a, 0x34, 0x80, 0xfa, 0xde, 0xc4, 0xdd, 0xa7, 0x5c, 0x87, 0xcd, 0x9d,
	0x22, 0x87, 0xec, 0x1d, 0xc9, 0x49, 0x15, 0x1d, 0xd4, 0x37, 0xd6, 0xdc, 0xad, 0xdb, 0x2d, 0x95,
	0xe7, 0xde, 0x6e, 0x79, 0x1b, 0x1a, 0x5e, 0xa0, 0x8f, 0xc6, 0xaa, 0xd9, 0x48, 0xec, 0xb6, 0x86,
	0xe3, 0x84, 0x22, 0x7b, 0x19, 0xa8, 0xf6, 0x25, 0x5c, 0x06, 0xaa, 0xbf, 0x9c, 0xcb, 0x40, 0x0e,
	0xd4, 0x95, 0xf6, 0xa4, 0x79, 0xe8, 0x8b, 0x06, 0xd2, 0x3b, 0x31, 0xac, 0x31, 0x62, 0x26, 0x54,
	0x19, 0x56, 0x07, 0x86, 0x85, 0x66, 0x42, 0x17, 0x1b, 0xa5, 0x1c, 0xf5, 0x8d, 0x35, 0x77, 0x67,
	0x0b, 0x1a, 0x66, 0xa6, 0xcc, 0x41, 0x67, 0x69, 0xf6, 0x41, 0xe7, 0x8b, 0xb7, 0x50, 0xe7, 0x63,
	0xc1, 0x4c, 0x97, 0x88, 0xdf, 0x82, 0x7a, 0x14, 0xd3, 0x81, 0xf7, 0xa9, 0xe6, 0x97, 0x4c, 0xf1,
	0x8e, 0x84, 0x62, 0x8d, 0x95, 0xe7, 0x16, 0x93, 0x81, 0xa0, 0xcb, 0x9f, 0x5b, 0x48, 0x28, 0xd6,
	0x58, 0xe7, 0x6f, 0xca, 0x50, 0xef, 0xc9, 0x91, 0xa1, 0x47, 0xd0, 0x10, 0x9e, 0x52, 0x16, 0x63,
	0x55, 0x95, 0xea, 0x9d, 0x93, 0xf9, 0xd5, 0xfb, 0x32, 0x1a, 0xbb, 0x4b, 0x39, 0x49, 0x97, 0x51,
	0x0a, 0xc3, 0x09, 0x57, 0x34, 0xd0, 0x47, 0x9c, 0x85, 0xab, 0xd7, 0xaa, 0xc7, 0xbd, 0x88, 0xba,
	0x33, 0x4f, 0x35, 0x03, 0xa8, 0x33, 0x19, 0xbb, 0x14, 0x2f, 0x60, 0x6b, 0x49, 0x92, 0x9b, 0xa5,
	0x44, 0xf9, 0x1b, 0x6b, 0x29, 0xce, 0x3f, 0x96, 0x00, 0x14, 0xe1, 0xb6, 0xc7, 0x38, 0xfa, 0xe4,
	0x98, 0x22, 0xdb, 0x27, 0x53, 0xa4, 0x68, 0x2d, 0xd5, 0x98, 0x2c, 0x47, 0x03, 0xb1, 0x94, 0x48,
	0xa1, 0xe6, 0x71, 0x3a, 0x66, 0xba, 0xe0, 0xf5, 0x61, 0xd1, 0xb1, 0xa5, 0x89, 0xe9, 0x6d, 0xc1,
	0x16, 0x2b, 0xee, 0xce, 0x3f, 0x94, 0x60, 0x51, 0x11, 0x98, 0x42, 0x01, 0x43, 0x8f, 0x00, 0xfa,
	0x34, 0xf2, 0xc3, 0xe9, 0x98, 0x06, 0xfc, 0xcc, 0x36, 0xf2, 0x8a, 0xb0, 0x8f, 0x8d, 0x84, 0x0f,
	0xb6, 0x78, 0xa2, 0x87, 0x30, 0x27, 0x72, 0x0c, 0xcf, 0x35, 0x47, 0x1c, 0xa7, 0x67, 0x2f, 0x4f,
	0x19, 0x7a, 0x8a, 0x09, 0x36, 0xdc, 0x9c, 0xbf, 0x6f, 0x9a, 0x29, 0x12, 0x76, 0x82, 0x3e, 0x2b,
	0xe5, 0x4e, 0x34, 0x55, 0x45, 0xe5, 0xf6, 0x4b, 0x3b, 0x01, 0x4a, 0x33, 0xe2, 0x67, 0x1f, 0x90,
	0xa2, 0x10, 0x1a, 0x5c, 0x6d, 0x44, 0x66, 0x36, 0xd7, 0x0b, 0x6f, 0x69, 0xa9, 0xed, 0x68, 0x00,
	0xc3, 0x89, 0x10, 0x14, 0x41, 0x83, 0xd3, 0x71, 0xe4, 0x13, 0x4e, 0x8b, 0x9f, 0x32, 0xec, 0x6a,
	0x4e, 0x96, 0x44, 0x0d, 0xc1, 0x89, 0x14, 0xf4, 0x3b, 0xd0, 0x62, 0x56, 0xa2, 0xa9, 0x23, 0x97,
	0x22, 0x0b, 0xd2, 0xe2, 0xa6, 0x4e, 0xa0, 0x6d, 0x08, 0xce, 0x48, 0x13, 0x01, 0x99, 0xeb, 0xc5,
	0xee, 0xc4, 0xe3, 0x3a, 0xba, 0x49, 0x02, 0x8c, 0xae, 0x02, 0x63, 0x83, 0x47, 0x3f, 0x28, 0xc1,
	0x52, 0x3f, 0x7b, 0x30, 0x6e, 0x2e, 0x44, 0x14, 0xb0, 0x8a, 0xdc, 0x51, 0x7b, 0x92, 0xc8, 0x2c,
	0xe5, 0x10, 0x0c, 0x1f, 0x13, 0x8e, 0xee, 0x00, 0xd2, 0x35, 0xac, 0x1b, 0xc4, 0xf3, 0x69, 0x1f,
	0x87, 0x93, 0xa0, 0x2f, 0xf3, 0x88, 0x46, 0x7a, 0xb9, 0x64, 0xf3, 0x18, 0x05, 0x9e, 0xd1, 0x0a,
	0xfd, 0xa8, 0x04, 0x0b, 0x7a, 0x29, 0xa8, 0xf2, 0xd7, 0xf2, 0x7c, 0xd1, 0x12, 0x62, 0xba, 0x9a,
	0xda, 0x3d, 0x9b, 0xb3, 0x2a, 0x21, 0x5e, 0xd2, 0x1d, 0x5c, 0xc8, 0xe0, 0x70, 0xb6, 0x13, 0xe8,
	0xcf, 0x4b, 0xea, 0x02, 0x8d, 0xe7, 0xd2, 0xf5, 0x20, 0x08, 0xb9, 0xbc, 0xd8, 0xc5, 0x74, 0x41,
	0xe5, 0x93, 0x97, 0xd9, 0x37, 0x8b, 0xbd, 0xea, 0x60, 0xe6, 0x7a, 0x4e, 0x96, 0x00, 0xcf, 0xe8,
	0xd3, 0xca, 0x87, 0x80, 0x8e, 0x0f, 0xf3, 0x34, 0xf5, 0xc3, 0x95, 0x4d, 0xf8, 0xea, 0x33, 0x3a,
	0x73, 0xaa, 0x32, 0xe4, 0x4f, 0xe6, 0xa0, 0x65, 0xef, 0x4a, 0x69, 0xf2, 0x5b, 0x3a, 0x69, 0xf2,
	0xfb, 0x9b, 0x76, 0xf2, 0x5b, 0x3e, 0xf5, 0x51, 0xff, 0xf3, 0xf3, 0x5e, 0x92, 0xcd, 0x7b, 0x2b,
	0xa7, 0x66, 0x7f, 0xaa, 0x94, 0xb7, 0xfa, 0x82, 0x94, 0xf7, 0x00, 0x6a, 0x41, 0xd8, 0xa7, 0xac,
	0xf8, 0xb5, 0x2a, 0x5b, 0xe7, 0x6d, 0xa1, 0x52, 0x6d, 0x48, 0xc9, 0xf6, 0x29, 0x61, 0x58, 0x89,
	0x43, 0x37, 0xe1, 0xa2, 0xf6, 0xba, 0xdd, 0xa9, 0xeb, 0xd3, 0x6e, 0x38, 0x09, 0x54, 0x9d, 0xa1,
	0xd6, 0x79, 0x5d, 0x37, 0xb8, 0xb8, 0x9b, 0x27, 0xc0, 0xc7, 0xdb, 0xa0, 0xef, 0x01, 0xb2, 0x81,
	0x4a, 0xbe, 0x3e, 0x29, 0x5d, 0x33, 0x36, 0xbc, 0x7b, 0x8c, 0xe2, 0x69, 0x8e, 0xbf, 0x80, 0x52,
	0x3c, 0x83, 0x15, 0x1a, 0xc2, 0x82, 0x4f, 0x18, 0x97, 0x20, 0xa1, 0x7f, 0x1d, 0x19, 0x9f, 0x66,
	0xc6, 0x92, 0xc5, 0xbe, 0x6d, 0x33, 0xc2, 0x59, 0xbe, 0xe8, 0x00, 0x9a, 0xe6, 0x1a, 0x28, 0xd3,
	0x15, 0x88, 0xdb, 0x45, 0xa7, 0x23, 0x89, 0x4d, 0x54, 0x5e, 0x90, 0xfc, 0xc4, 0xa9, 0xa8, 0x95,
	0xef, 0xab, 0x6a, 0xd6, 0x33, 0x97, 0xda, 0xc7, 0xf6, 0x52, 0x2b, 0x14, 0x96, 0xa6, 0x45, 0x33,
	0x7b, 0xc1, 0xfe, 0x5b, 0x19, 0x5a, 0x3d, 0x9f, 0xb8, 0x49, 0x21, 0x21, 0x9b, 0xcb, 0x96, 0xce,
	0xbd, 0x7e, 0xf8, 0x00, 0x80, 0xc9, 0xfe, 0xc8, 0x5a, 0xc2, 0xa9, 0xce, 0x8f, 0x65, 0xec, 0xd6,
	0x4b, 0x1a, 0x63, 0x8b, 0xd1, 0xe9, 0x4b, 0x1a, 0x62, 0x77, 0x1e, 0x91, 0x20, 0xa0, 0x7e, 0x7e,
	0x19, 0x77, 0x15, 0x18, 0x1b, 0xbc, 0xbd, 0xe2, 0x6b, 0xcf, 0x5f, 0xf1, 0xce, 0x7f, 0x56, 0x01,
	0xf5, 0x38, 0x09, 0xfa, 0x24, 0xee, 0x6f, 0x5d, 0x67, 0x46, 0xe9, 0x7f, 0xf8, 0xac, 0x8b, 0xf8,
	0xa5, 0xc2, 0x17, 0xf1, 0x97, 0x4f, 0x77, 0x09, 0xdf, 0x7a, 0x4d, 0x51, 0x3e, 0x97, 0xd7, 0x14,
	0xf7, 0xec, 0xd7, 0x14, 0x6a, 0x62, 0xde, 0x99, 0xf5, 0x9a, 0xe2, 0x6b, 0x5b, 0x93, 0x3d, 0x1a,
	0x07, 0x94, 0xd3, 0xe4, 0x70, 0xf0, 0x04, 0x6f, 0x2a, 0xce, 0xbf, 0xfe, 0x3d, 0x80, 0x85, 0x88,
	0x70, 0x77, 0xd4, 0xe3, 0x31, 0xe1, 0x74, 0x38, 0xd5, 0x26, 0xf1, 0xa1, 0xf1, 0x42, 0x3b, 0x36,
	0xf2, 0xe9, 0xe1, 0xea, 0x2f, 0x3d, 0xeb, 0x51, 0x15, 0x9f, 0x46, 0x94, 0xb5, 0x25, 0xb9, 0x2c,
	0x26, 0x67, 0xd9, 0xa2, 0x6b, 0x00, 0xbe, 0x77, 0x40, 0xef, 0xa7, 0x57, 0xe7, 0x1a, 0x69, 0xdf,
	0xb6, 0x13, 0x0c, 0xb6, 0xa8, 0x9c, 0x35, 0x68, 0x29, 0x0f, 0xa0, 0xcf, 0x6c, 0x57, 0xa1, 0x46,
	0x7c, 0x3f, 0x7c, 0x22, 0x97, 0x79, 0x45, 0x55, 0x4c, 0xd7, 0x05, 0x00, 0x2b, 0xb8, 0x73, 0x54,
	0x82, 0x4c, 0x04, 0x8b, 0x46, 0x50, 0x1d, 0x71, 0x1e, 0x15, 0x7f, 0x69, 0x93, 0xbf, 0x7d, 0xa1,
	0x6e, 0x68, 0x08, 0x28, 0x96, 0x12, 0x84, 0xa4, 0x80, 0x70, 0x56, 0xdc, 0x0a, 0xf3, 0xc7, 0x49,
	0x4a, 0x92, 0x80, 0x62, 0x29, 0xc1, 0xf9, 0xcb, 0x12, 0x34, 0x93, 0xd3, 0x06, 0xa1, 0x57, 0x97,
	0x74, 0x69, 0xcc, 0x77, 0xd2, 0xfb, 0x57, 0x89, 0x5e, 0xbb, 0xeb, 0x06, 0x83, 0x2d, 0x2a, 0x75,
	0xb9, 0xca, 0xa3, 0x01, 0x4f, 0xda, 0x1d, 0xbb, 0x5c, 0x65, 0x63, 0x71, 0x8e, 0x1a, 0xfd, 0x2a,
	0x2c, 0x28, 0x88, 0xb9, 0xc9, 0xa4, 0xd6, 0x41, 0xb2, 0x73, 0x75, 0x6d, 0x24, 0xce, 0xd2, 0x3a,
	0x7f, 0x54, 0x81, 0x24, 0xb7, 0x31, 0x77, 0xbe, 0x45, 0x18, 0xe7, 0xba, 0x62, 0x8b, 0xb6, 0xde,
	0xd6, 0x1d, 0x0b, 0x2a, 0x53, 0x0a, 0x3c, 0xa3, 0x15, 0xba, 0x23, 0xdf, 0x8b, 0x70, 0x22, 0x4c,
	0x52, 0x4f, 0xc3, 0x9b, 0xb3, 0x1c, 0x71, 0xd7, 0x10, 0x25, 0x2f, 0x40, 0xd4, 0x4f, 0x9c, 0x36,
	0x47, 0x9b, 0x30, 0x77, 0x10, 0xfa, 0x93, 0x31, 0x35, 0xcf, 0x9c, 0x56, 0x66, 0x71, 0xfa, 0x48,
	0x92, 0x58, 0x85, 0x69, 0xd5, 0x04, 0x9b, 0xb6, 0x88, 0xc2, 0xa2, 0xac, 0xfb, 0x79, 0x7c, 0xaa,
	0xaf, 0xea, 0xe9, 0x9c, 0xed, 0xad, 0x59, 0xec, 0x76, 0xc2, 0x7e, 0x2f, 0x4b, 0xdd, 0x79, 0xf5,
	0xe8, 0x70, 0x75, 0x31, 0x07, 0xc4, 0x79, 0x9e, 0xe8, 0x3b, 0xc9, 0x6d, 0x77, 0xc1, 0xfb, 0x6b,
	0xcf, 0xe2, 0x1d, 0x51, 0x57, 0x19, 0x53, 0x5a, 0xdd, 0x71, 0x7a, 0x00, 0xe9, 0xed, 0x45, 0xf5,
	0x6a, 0x83, 0xc4, 0xa6, 0x0c, 0x6b, 0xbd, 0xda, 0x20, 0x31, 0xc7, 0x0a, 0x87, 0xae, 0x40, 0x95,
	0xf1, 0x30, 0xca, 0xd7, 0xd8, 0x7a, 0x3c, 0x8c, 0xb0, 0xc4, 0x38, 0xff, 0x5a, 0x86, 0x39, 0xb3,
	0x55, 0x30, 0x2b, 0x4b, 0x2e, 0x15, 0x8d, 0x53, 0x34, 0xd3, 0x24, 0x59, 0x6e, 0x3d, 0x23, 0x51,
	0xce, 0x3a, 0xd5, 0xf2, 0xb9, 0x3b, 0xd5, 0x7d, 0xa8, 0x47, 0xd2, 0x65, 0xe9, 0x88, 0xfd, 0x66,
	0x71, 0xd9, 0x92, 0x9d, 0xda, 0x91, 0xd4, 0x37, 0xd6, 0x22, 0x9c, 0x7f, 0x2f, 0xc1, 0x52, 0xbe,
	0x87, 0x68, 0x1f, 0x2a, 0x2c, 0x76, 0xb5, 0xc6, 0x77, 0x5e, 0xde, 0xd0, 0xd5, 0x6e, 0xa8, 0xce,
	0x38, 0x7b, 0xb1, 0x8b, 0x85, 0x14, 0x61, 0x11, 0x7d, 0xca, 0x78, 0xde, 0x22, 0x36, 0x28, 0xe3,
	0x58, 0x62, 0xd0, 0xf6, 0xf1, 0x5d, 0xb3, 0x3d, 0x6b, 0xd7, 0x7c, 0x3d, 0x2f, 0x6f, 0xd6, 0x9e,
	0xe9, 0xfc, 0x53, 0x19, 0xbe, 0x32, 0xbb, 0x63, 0xc2, 0xb5, 0xa5, 0xb9, 0xbf, 0xe5, 0x4c, 0x12,
	0xd7, 0xb6, 0x91, 0xc1, 0xe2, 0x1c, 0xb5, 0x74, 0xa7, 0x6a, 0x55, 0x99, 0xd7, 0xba, 0xb6, 0x3b,
	0x4d, 0x30, 0xd8, 0xa2, 0x42, 0xeb, 0xb0, 0xa8, 0x7f, 0xed, 0xda, 0xf5, 0x20, 0xeb, 0x1a, 0x41,
	0x37, 0x8b, 0xc6, 0x79, 0x7a, 0x11, 0x92, 0xf5, 0x09, 0x27, 0xa6, 0x80, 0x6f, 0x85, 0x64, 0x1b,
	0x0a, 0x8c, 0x0d, 0x1e, 0x5d, 0x87, 0x96, 0xf8, 0x4c, 0x44, 0x55, 0xb3, 0x0f, 0x6c, 0x36, 0x2c,
	0x1c, 0xce, 0x50, 0xa6, 0x0f, 0x22, 0xd4, 0x16, 0x7f, 0xec, 0x41, 0x84, 0xf3, 0xf3, 0x12, 0x2c,
	0x64, 0xec, 0x0d, 0x0d, 0xa0, 0xb2, 0x7f, 0x9d, 0x69, 0x33, 0xda, 0x7a, 0x89, 0x57, 0xa4, 0x94,
	0x05, 0x09, 0xb0, 0x10, 0x80, 0x1e, 0x27, 0x45, 0xe6, 0x72, 0xe1, 0x9a, 0x96, 0x15, 0x31, 0xe8,
	0x08, 0x2e, 0x5b, 0x60, 0xde, 0x4c, 0x06, 0xd9, 0x7b, 0xe2, 0x71, 0x77, 0x84, 0x5e, 0x87, 0x0a,
	0x09, 0xa6, 0x32, 0xa8, 0x68, 0xaa, 0x7e, 0xad, 0x07, 0x53, 0x2c, 0x60, 0x12, 0xe5, 0xfb, 0xfa,
	0x52, 0xa6, 0x42, 0xf9, 0x3e, 0x16, 0x30, 0xe7, 0x4f, 0x9b, 0xb0, 0x98, 0xf3, 0x47, 0x27, 0xb8,
	0xe6, 0xb9, 0x0f, 0x75, 0x26, 0xa5, 0xea, 0x81, 0x16, 0xf7, 0x0c, 0x6a, 0x10, 0x7a, 0xa4, 0xf2,
	0x1b, 0x6b, 0x11, 0x68, 0xa8, 0x66, 0x4f, 0xf9, 0xa0, 0xed, 0x42, 0x2a, 0xcd, 0x65, 0x00, 0xb9,
	0xe9, 0xfb, 0xac, 0x04, 0x2d, 0x62, 0xbd, 0x1e, 0xd6, 0xbb, 0xdc, 0xdd, 0x22, 0xb1, 0xf8, 0xb1,
	0x87, 0xd3, 0xaa, 0x40, 0x69, 0x23, 0x70, 0x46, 0x28, 0x72, 0x75, 0xb0, 0x57, 0x2b, 0xfa, 0x6e,
	0xd3, 0xba, 0xa0, 0x78, 0x2c, 0xce, 0x7b, 0x02, 0x4d, 0xf2, 0x84, 0xa9, 0xff, 0x06, 0xd0, 0x87,
	0x6d, 0x45, 0x52, 0x8e, 0xdc, 0xdf, 0x0c, 0xe8, 0x53, 0x3e, 0x03, 0xc5, 0xa9, 0x2c, 0x14, 0x43,
	0xdd, 0x95, 0x8f, 0xd1, 0xf4, 0xed, 0x87, 0x9b, 0x2f, 0xe9, 0x51, 0x5b, 0xe7, 0xa2, 0x0c, 0xd9,
	0x6c, 0x10, 0xd6, 0x92, 0xd0, 0x10, 0x6a, 0xfb, 0x64, 0xb0, 0x4f, 0x74, 0x19, 0xa3, 0xc0, 0xaa,
	0xb4, 0xef, 0xfa, 0x29, 0xcf, 0x23, 0x21, 0x58, 0xf1, 0x17, 0x53, 0x27, 0xa3, 0xe7, 0x66, 0xd1,
	0xa9, 0xb3, 0xee, 0x46, 0xe5, 0x03, 0x67, 0x31, 0x1a, 0x99, 0x61, 0xeb, 0xbb, 0x14, 0x45, 0x7c,
	0x8c, 0x55, 0x81, 0x50, 0xa3, 0x91, 0x10, 0xac, 0xf8, 0x0b, 0x1b, 0x09, 0xcd, 0x85, 0x07, 0x7d,
	0xab, 0xa2, 0x80, 0x8d, 0xe4, 0xef, 0x4e, 0x28, 0x1b, 0x49, 0xa0, 0x38, 0x95, 0xe5, 0xb8, 0x30,
	0x6f, 0xbd, 0xa7, 0x3e, 0xc1, 0x8b, 0xba, 0x6b, 0x00, 0x07, 0x34, 0xf6, 0x06, 0x53, 0x11, 0xdb,
	0xeb, 0x97, 0x9d, 0xc9, 0x76, 0xf7, 0x51, 0x82, 0xc1, 0x16, 0x55, 0xa7, 0xfd, 0xf9, 0x17, 0x97,
	0x2f, 0xfc, 0xf4, 0x8b, 0xcb, 0x17, 0x7e, 0xf6, 0xc5, 0xe5, 0x0b, 0xbf, 0x7f, 0x74, 0xb9, 0xf4,
	0xf9, 0xd1, 0xe5, 0xd2, 0x4f, 0x8f, 0x2e, 0x97, 0x7e, 0x76, 0x74, 0xb9, 0xf4, 0xcf, 0x47, 0x97,
	0x4b, 0x7f, 0xf2, 0xf3, 0xcb, 0x17, 0x3e, 0x6e, 0x98, 0xfe, 0xff, 0x4f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x5b, 0x71, 0xda, 0xb8, 0xc5, 0x44, 0x00, 0x00,
}

func (m *AWSLambdaTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSLambdaTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSLambdaTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.Region)
	copy(dAtA[i:], m.Region)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Region)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x22
	if m.SecretKey != nil {
		{
			size, err := m.SecretKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AccessKey != nil {
		{
			size, err := m.AccessKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.FunctionName)
	copy(dAtA[i:], m.FunctionName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FunctionName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ArgoWorkflowTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgoWorkflowTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArgoWorkflowTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.GroupVersionResource.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.Operation)
	copy(dAtA[i:], m.Operation)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Operation)))
	i--
	dAtA[i] = 0x12
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ArtifactLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArtifactLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArtifactLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resource != nil {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Git != nil {
		{
			size, err := m.Git.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Configmap != nil {
		{
			size, err := m.Configmap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.URL != nil {
		{
			size, err := m.URL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Inline != nil {
		i -= len(*m.Inline)
		copy(dAtA[i:], *m.Inline)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Inline)))
		i--
		dAtA[i] = 0x12
	}
	if m.S3 != nil {
		{
			size, err := m.S3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Backoff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Backoff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Backoff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.Steps))
	i--
	dAtA[i] = 0x20
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Jitter))))
	i--
	dAtA[i] = 0x19
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Factor))))
	i--
	dAtA[i] = 0x11
	i = encodeVarintGenerated(dAtA, i, uint64(m.Duration))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *BasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x4a
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Username != nil {
		{
			size, err := m.Username.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigmapArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigmapArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigmapArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Key)
	copy(dAtA[i:], m.Key)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CustomTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Spec) > 0 {
		keysForSpec := make([]string, 0, len(m.Spec))
		for k := range m.Spec {
			keysForSpec = append(keysForSpec, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSpec)
		for iNdEx := len(keysForSpec) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Spec[string(keysForSpec[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForSpec[iNdEx])
			copy(dAtA[i:], keysForSpec[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForSpec[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.ServerNameOverride)
	copy(dAtA[i:], m.ServerNameOverride)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServerNameOverride)))
	i--
	dAtA[i] = 0x22
	i -= len(m.CertFilePath)
	copy(dAtA[i:], m.CertFilePath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CertFilePath)))
	i--
	dAtA[i] = 0x1a
	i--
	if m.Secure {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.ServerURL)
	copy(dAtA[i:], m.ServerURL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServerURL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Comparator)
	copy(dAtA[i:], m.Comparator)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Comparator)))
	i--
	dAtA[i] = 0x22
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DependencyGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DependencyGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DependencyGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependencies[iNdEx])
			copy(dAtA[i:], m.Dependencies[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Dependencies[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	i -= len(m.Subject)
	copy(dAtA[i:], m.Subject)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Subject)))
	i--
	dAtA[i] = 0x32
	i -= len(m.DataContentType)
	copy(dAtA[i:], m.DataContentType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataContentType)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x22
	i -= len(m.SpecVersion)
	copy(dAtA[i:], m.SpecVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.SpecVersion)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Source)
	copy(dAtA[i:], m.Source)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Source)))
	i--
	dAtA[i] = 0x12
	i -= len(m.ID)
	copy(dAtA[i:], m.ID)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ID)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDependency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDependency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Filters != nil {
		{
			size, err := m.Filters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.EventName)
	copy(dAtA[i:], m.EventName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EventName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.GatewayName)
	copy(dAtA[i:], m.GatewayName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.GatewayName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *EventDependencyFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDependencyFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDependencyFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FileArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GitArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Remote != nil {
		{
			size, err := m.Remote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	i -= len(m.Ref)
	copy(dAtA[i:], m.Ref)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Ref)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.Tag)
	copy(dAtA[i:], m.Tag)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Tag)))
	i--
	dAtA[i] = 0x42
	i -= len(m.Branch)
	copy(dAtA[i:], m.Branch)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Branch)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.FilePath)
	copy(dAtA[i:], m.FilePath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.FilePath)))
	i--
	dAtA[i] = 0x32
	i -= len(m.SSHKeyPath)
	copy(dAtA[i:], m.SSHKeyPath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.SSHKeyPath)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x22
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.CloneDirectory)
	copy(dAtA[i:], m.CloneDirectory)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CloneDirectory)))
	i--
	dAtA[i] = 0x12
	i -= len(m.URL)
	copy(dAtA[i:], m.URL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GitCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Username != nil {
		{
			size, err := m.Username.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitRemoteConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitRemoteConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitRemoteConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URLS) > 0 {
		for iNdEx := len(m.URLS) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.URLS[iNdEx])
			copy(dAtA[i:], m.URLS[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.URLS[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HTTPSubscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPSubscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *HTTPTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		keysForHeaders := make([]string, 0, len(m.Headers))
		for k := range m.Headers {
			keysForHeaders = append(keysForHeaders, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
		for iNdEx := len(keysForHeaders) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Headers[string(keysForHeaders[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForHeaders[iNdEx])
			copy(dAtA[i:], keysForHeaders[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForHeaders[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.BasicAuth != nil {
		{
			size, err := m.BasicAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Timeout))
	i--
	dAtA[i] = 0x30
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.Method)
	copy(dAtA[i:], m.Method)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Method)))
	i--
	dAtA[i] = 0x22
	if m.TLS != nil {
		{
			size, err := m.TLS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.URL)
	copy(dAtA[i:], m.URL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *K8SResourcePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SResourcePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SResourcePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.ErrorOnBackoffTimeout {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Backoff.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KafkaTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KafkaTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KafkaTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.PartitioningKey)
	copy(dAtA[i:], m.PartitioningKey)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PartitioningKey)))
	i--
	dAtA[i] = 0x52
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TLS != nil {
		{
			size, err := m.TLS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.FlushFrequency))
	i--
	dAtA[i] = 0x38
	i--
	if m.Compress {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.RequiredAcks))
	i--
	dAtA[i] = 0x28
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.Partition))
	i--
	dAtA[i] = 0x18
	i -= len(m.Topic)
	copy(dAtA[i:], m.Topic)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Topic)))
	i--
	dAtA[i] = 0x12
	i -= len(m.URL)
	copy(dAtA[i:], m.URL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NATSSubscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NATSSubscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NATSSubscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Subject)
	copy(dAtA[i:], m.Subject)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Subject)))
	i--
	dAtA[i] = 0x12
	i -= len(m.ServerURL)
	copy(dAtA[i:], m.ServerURL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServerURL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NATSTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NATSTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NATSTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TLS != nil {
		{
			size, err := m.TLS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	i -= len(m.Subject)
	copy(dAtA[i:], m.Subject)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Subject)))
	i--
	dAtA[i] = 0x12
	i -= len(m.URL)
	copy(dAtA[i:], m.URL)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.URL)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResolvedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.UpdatedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x42
	{
		size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x22
	i -= len(m.DisplayName)
	copy(dAtA[i:], m.DisplayName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DisplayName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i -= len(m.ID)
	copy(dAtA[i:], m.ID)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ID)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OpenWhiskTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenWhiskTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenWhiskTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.ActionName)
	copy(dAtA[i:], m.ActionName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ActionName)))
	i--
	dAtA[i] = 0x2a
	if m.AuthToken != nil {
		{
			size, err := m.AuthToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Host)
	copy(dAtA[i:], m.Host)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Host)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *S3Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Artifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Artifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Events[iNdEx])
			copy(dAtA[i:], m.Events[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Events[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SecretKey != nil {
		{
			size, err := m.SecretKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AccessKey != nil {
		{
			size, err := m.AccessKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	i--
	if m.Insecure {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i -= len(m.Region)
	copy(dAtA[i:], m.Region)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Region)))
	i--
	dAtA[i] = 0x1a
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Endpoint)
	copy(dAtA[i:], m.Endpoint)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Endpoint)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *S3Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Key)
	copy(dAtA[i:], m.Key)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Key)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *S3Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Suffix)
	copy(dAtA[i:], m.Suffix)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Suffix)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Sensor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sensor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sensor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SensorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SensorResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorResources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorResources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceLabels) > 0 {
		keysForServiceLabels := make([]string, 0, len(m.ServiceLabels))
		for k := range m.ServiceLabels {
			keysForServiceLabels = append(keysForServiceLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForServiceLabels)
		for iNdEx := len(keysForServiceLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ServiceLabels[string(keysForServiceLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForServiceLabels[iNdEx])
			copy(dAtA[i:], keysForServiceLabels[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForServiceLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ServiceAnnotations) > 0 {
		keysForServiceAnnotations := make([]string, 0, len(m.ServiceAnnotations))
		for k := range m.ServiceAnnotations {
			keysForServiceAnnotations = append(keysForServiceAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForServiceAnnotations)
		for iNdEx := len(keysForServiceAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ServiceAnnotations[string(keysForServiceAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForServiceAnnotations[iNdEx])
			copy(dAtA[i:], keysForServiceAnnotations[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForServiceAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	i--
	if m.ErrorOnFailedRound {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	if len(m.DependencyGroups) > 0 {
		for iNdEx := len(m.DependencyGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DependencyGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	i -= len(m.Circuit)
	copy(dAtA[i:], m.Circuit)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Circuit)))
	i--
	dAtA[i] = 0x2a
	if m.Subscription != nil {
		{
			size, err := m.Subscription.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Template.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Triggers) > 0 {
		for iNdEx := len(m.Triggers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Triggers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dependencies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SensorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.LastCycleTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	i -= len(m.TriggerCycleStatus)
	copy(dAtA[i:], m.TriggerCycleStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.TriggerCycleStatus)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintGenerated(dAtA, i, uint64(m.TriggerCycleCount))
	i--
	dAtA[i] = 0x30
	if len(m.Nodes) > 0 {
		keysForNodes := make([]string, 0, len(m.Nodes))
		for k := range m.Nodes {
			keysForNodes = append(keysForNodes, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForNodes)
		for iNdEx := len(keysForNodes) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Nodes[string(keysForNodes[iNdEx])]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(keysForNodes[iNdEx])
			copy(dAtA[i:], keysForNodes[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForNodes[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CompletedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SlackTrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlackTrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlackTrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Channel)
	copy(dAtA[i:], m.Channel)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Channel)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Namespace)
	copy(dAtA[i:], m.Namespace)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Namespace)))
	i--
	dAtA[i] = 0x1a
	if m.SlackToken != nil {
		{
			size, err := m.SlackToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StandardK8STrigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StandardK8STrigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StandardK8STrigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.LiveObject {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i -= len(m.PatchStrategy)
	copy(dAtA[i:], m.PatchStrategy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PatchStrategy)))
	i--
	dAtA[i] = 0x2a
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.Operation)
	copy(dAtA[i:], m.Operation)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Operation)))
	i--
	dAtA[i] = 0x1a
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupVersionResource != nil {
		{
			size, err := m.GroupVersionResource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintGenerated(dAtA, i, uint64(m.Allow[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *Subscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NATS != nil {
		{
			size, err := m.NATS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HTTP != nil {
		{
			size, err := m.HTTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ClientKeyPath)
	copy(dAtA[i:], m.ClientKeyPath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ClientKeyPath)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ClientCertPath)
	copy(dAtA[i:], m.ClientCertPath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ClientCertPath)))
	i--
	dAtA[i] = 0x12
	i -= len(m.CACertPath)
	copy(dAtA[i:], m.CACertPath)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CACertPath)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Template) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Template) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Template) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SecurityContext != nil {
		{
			size, err := m.SecurityContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Volumes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Container != nil {
		{
			size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.ServiceAccountName)
	copy(dAtA[i:], m.ServiceAccountName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServiceAccountName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TimeFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Stop)
	copy(dAtA[i:], m.Stop)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Stop)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Start)
	copy(dAtA[i:], m.Start)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Start)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Trigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Template != nil {
		{
			size, err := m.Template.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Operation)
	copy(dAtA[i:], m.Operation)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Operation)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Dest)
	copy(dAtA[i:], m.Dest)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Dest)))
	i--
	dAtA[i] = 0x12
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerParameterSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerParameterSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerParameterSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.DataKey)
	copy(dAtA[i:], m.DataKey)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataKey)))
	i--
	dAtA[i] = 0x32
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = encodeVarintGenerated(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x2a
	}
	i -= len(m.DataTemplate)
	copy(dAtA[i:], m.DataTemplate)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DataTemplate)))
	i--
	dAtA[i] = 0x22
	i -= len(m.ContextTemplate)
	copy(dAtA[i:], m.ContextTemplate)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ContextTemplate)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ContextKey)
	copy(dAtA[i:], m.ContextKey)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ContextKey)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DependencyName)
	copy(dAtA[i:], m.DependencyName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.DependencyName)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TriggerPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.K8s != nil {
		{
			size, err := m.K8s.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerSwitch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerSwitch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerSwitch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.All) > 0 {
		for iNdEx := len(m.All) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.All[iNdEx])
			copy(dAtA[i:], m.All[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.All[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Any) > 0 {
		for iNdEx := len(m.Any) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Any[iNdEx])
			copy(dAtA[i:], m.Any[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.Any[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TriggerTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenWhisk != nil {
		{
			size, err := m.OpenWhisk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Slack != nil {
		{
			size, err := m.Slack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.NATS != nil {
		{
			size, err := m.NATS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Kafka != nil {
		{
			size, err := m.Kafka.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CustomTrigger != nil {
		{
			size, err := m.CustomTrigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AWSLambda != nil {
		{
			size, err := m.AWSLambda.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.HTTP != nil {
		{
			size, err := m.HTTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ArgoWorkflow != nil {
		{
			size, err := m.ArgoWorkflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.K8s != nil {
		{
			size, err := m.K8s.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Switch != nil {
		{
			size, err := m.Switch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *URLArtifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLArtifact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLArtifact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.VerifyCert {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSLambdaTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FunctionName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.AccessKey != nil {
		l = m.AccessKey.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SecretKey != nil {
		l = m.SecretKey.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Region)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *ArgoWorkflowTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Operation)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.GroupVersionResource.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ArtifactLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S3 != nil {
		l = m.S3.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Inline != nil {
		l = len(*m.Inline)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.URL != nil {
		l = m.URL.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Configmap != nil {
		l = m.Configmap.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Resource != nil {
		l = len(m.Resource)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *Backoff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Duration))
	n += 9
	n += 9
	n += 1 + sovGenerated(uint64(m.Steps))
	return n
}

func (m *BasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Username != nil {
		l = m.Username.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ConfigmapArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Key)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *CustomTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerURL)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	l = len(m.CertFilePath)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ServerNameOverride)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Spec) > 0 {
		for k, v := range m.Spec {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *DataFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.Comparator)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *DependencyGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Dependencies) > 0 {
		for _, s := range m.Dependencies {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *EventContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Source)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.SpecVersion)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataContentType)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Subject)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Time.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *EventDependency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.GatewayName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.EventName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *EventDependencyFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *FileArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *GitArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CloneDirectory)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.SSHKeyPath)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.FilePath)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Branch)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Tag)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Ref)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Remote != nil {
		l = m.Remote.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *GitCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Username != nil {
		l = m.Username.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *GitRemoteConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.URLS) > 0 {
		for _, s := range m.URLS {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *HTTPSubscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.Port))
	return n
}

func (m *HTTPTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.TLS != nil {
		l = m.TLS.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Method)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.Timeout))
	if m.BasicAuth != nil {
		l = m.BasicAuth.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *K8SResourcePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	l = m.Backoff.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	return n
}

func (m *KafkaTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Topic)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Partition))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.RequiredAcks))
	n += 2
	n += 1 + sovGenerated(uint64(m.FlushFrequency))
	if m.TLS != nil {
		l = m.TLS.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.PartitioningKey)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NATSSubscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerURL)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Subject)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *NATSTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Subject)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.TLS != nil {
		l = m.TLS.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DisplayName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.StartedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.CompletedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = m.UpdatedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ResolvedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *OpenWhiskTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Version)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	if m.AuthToken != nil {
		l = m.AuthToken.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.ActionName)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *S3Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Region)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	if m.AccessKey != nil {
		l = m.AccessKey.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.SecretKey != nil {
		l = m.SecretKey.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, s := range m.Events {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *S3Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *S3Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Suffix)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Sensor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *SensorList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *SensorResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *SensorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for _, e := range m.Dependencies {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.Triggers) > 0 {
		for _, e := range m.Triggers {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.Template.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Circuit)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.DependencyGroups) > 0 {
		for _, e := range m.DependencyGroups {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 2
	if len(m.ServiceAnnotations) > 0 {
		for k, v := range m.ServiceAnnotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	if len(m.ServiceLabels) > 0 {
		for k, v := range m.ServiceLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SensorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.StartedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.CompletedAt.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + l + sovGenerated(uint64(l))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	n += 1 + sovGenerated(uint64(m.TriggerCycleCount))
	l = len(m.TriggerCycleStatus)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.LastCycleTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *SlackTrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.SlackToken != nil {
		l = m.SlackToken.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Namespace)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Channel)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *StandardK8STrigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupVersionResource != nil {
		l = m.GroupVersionResource.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Operation)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = len(m.PatchStrategy)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	return n
}

func (m *StatusPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			n += 1 + sovGenerated(uint64(e))
		}
	}
	return n
}

func (m *Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HTTP != nil {
		l = m.HTTP.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NATS != nil {
		l = m.NATS.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TLSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CACertPath)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ClientCertPath)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ClientKeyPath)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Template) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceAccountName)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.SecurityContext != nil {
		l = m.SecurityContext.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TimeFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Stop)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Template != nil {
		l = m.Template.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TriggerParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Dest)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Operation)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *TriggerParameterSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DependencyName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ContextKey)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ContextTemplate)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.DataTemplate)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.DataKey)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *TriggerPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8s != nil {
		l = m.K8s.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *TriggerSwitch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Any) > 0 {
		for _, s := range m.Any {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if len(m.All) > 0 {
		for _, s := range m.All {
			l = len(s)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *TriggerTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Switch != nil {
		l = m.Switch.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.K8s != nil {
		l = m.K8s.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.ArgoWorkflow != nil {
		l = m.ArgoWorkflow.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.HTTP != nil {
		l = m.HTTP.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.AWSLambda != nil {
		l = m.AWSLambda.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.CustomTrigger != nil {
		l = m.CustomTrigger.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Kafka != nil {
		l = m.Kafka.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.NATS != nil {
		l = m.NATS.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.Slack != nil {
		l = m.Slack.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	if m.OpenWhisk != nil {
		l = m.OpenWhisk.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	return n
}

func (m *URLArtifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSLambdaTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&AWSLambdaTrigger{`,
		`FunctionName:` + fmt.Sprintf("%v", this.FunctionName) + `,`,
		`AccessKey:` + strings.Replace(fmt.Sprintf("%v", this.AccessKey), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`SecretKey:` + strings.Replace(fmt.Sprintf("%v", this.SecretKey), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArgoWorkflowTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&ArgoWorkflowTrigger{`,
		`Source:` + strings.Replace(this.Source.String(), "ArtifactLocation", "ArtifactLocation", 1) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`GroupVersionResource:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.GroupVersionResource), "GroupVersionResource", "v11.GroupVersionResource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ArtifactLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ArtifactLocation{`,
		`S3:` + strings.Replace(this.S3.String(), "S3Artifact", "S3Artifact", 1) + `,`,
		`Inline:` + valueToStringGenerated(this.Inline) + `,`,
		`File:` + strings.Replace(this.File.String(), "FileArtifact", "FileArtifact", 1) + `,`,
		`URL:` + strings.Replace(this.URL.String(), "URLArtifact", "URLArtifact", 1) + `,`,
		`Configmap:` + strings.Replace(this.Configmap.String(), "ConfigmapArtifact", "ConfigmapArtifact", 1) + `,`,
		`Git:` + strings.Replace(this.Git.String(), "GitArtifact", "GitArtifact", 1) + `,`,
		`Resource:` + valueToStringGenerated(this.Resource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Backoff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Backoff{`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Factor:` + fmt.Sprintf("%v", this.Factor) + `,`,
		`Jitter:` + fmt.Sprintf("%v", this.Jitter) + `,`,
		`Steps:` + fmt.Sprintf("%v", this.Steps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BasicAuth{`,
		`Username:` + strings.Replace(fmt.Sprintf("%v", this.Username), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigmapArtifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigmapArtifact{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	keysForSpec := make([]string, 0, len(this.Spec))
	for k := range this.Spec {
		keysForSpec = append(keysForSpec, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSpec)
	mapStringForSpec := "map[string]string{"
	for _, k := range keysForSpec {
		mapStringForSpec += fmt.Sprintf("%v: %v,", k, this.Spec[k])
	}
	mapStringForSpec += "}"
	s := strings.Join([]string{`&CustomTrigger{`,
		`ServerURL:` + fmt.Sprintf("%v", this.ServerURL) + `,`,
		`Secure:` + fmt.Sprintf("%v", this.Secure) + `,`,
		`CertFilePath:` + fmt.Sprintf("%v", this.CertFilePath) + `,`,
		`ServerNameOverride:` + fmt.Sprintf("%v", this.ServerNameOverride) + `,`,
		`Spec:` + mapStringForSpec + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataFilter{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Comparator:` + fmt.Sprintf("%v", this.Comparator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DependencyGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DependencyGroup{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Dependencies:` + fmt.Sprintf("%v", this.Dependencies) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Event{`,
		`Context:` + strings.Replace(this.Context.String(), "EventContext", "EventContext", 1) + `,`,
		`Data:` + valueToStringGenerated(this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventContext) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventContext{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`SpecVersion:` + fmt.Sprintf("%v", this.SpecVersion) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DataContentType:` + fmt.Sprintf("%v", this.DataContentType) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Time:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Time), "Time", "v11.Time", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventDependency) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventDependency{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`GatewayName:` + fmt.Sprintf("%v", this.GatewayName) + `,`,
		`EventName:` + fmt.Sprintf("%v", this.EventName) + `,`,
		`Filters:` + strings.Replace(this.Filters.String(), "EventDependencyFilter", "EventDependencyFilter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventDependencyFilter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]DataFilter{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(strings.Replace(f.String(), "DataFilter", "DataFilter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&EventDependencyFilter{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Time:` + strings.Replace(this.Time.String(), "TimeFilter", "TimeFilter", 1) + `,`,
		`Context:` + strings.Replace(this.Context.String(), "EventContext", "EventContext", 1) + `,`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileArtifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileArtifact{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitArtifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitArtifact{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`CloneDirectory:` + fmt.Sprintf("%v", this.CloneDirectory) + `,`,
		`Creds:` + strings.Replace(this.Creds.String(), "GitCreds", "GitCreds", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`SSHKeyPath:` + fmt.Sprintf("%v", this.SSHKeyPath) + `,`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`Branch:` + fmt.Sprintf("%v", this.Branch) + `,`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Ref:` + fmt.Sprintf("%v", this.Ref) + `,`,
		`Remote:` + strings.Replace(this.Remote.String(), "GitRemoteConfig", "GitRemoteConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitCreds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitCreds{`,
		`Username:` + strings.Replace(fmt.Sprintf("%v", this.Username), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GitRemoteConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GitRemoteConfig{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`URLS:` + fmt.Sprintf("%v", this.URLS) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPSubscription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPSubscription{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]string{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&HTTPTrigger{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`TLS:` + strings.Replace(this.TLS.String(), "TLSConfig", "TLSConfig", 1) + `,`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`BasicAuth:` + strings.Replace(this.BasicAuth.String(), "BasicAuth", "BasicAuth", 1) + `,`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SResourcePolicy) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&K8SResourcePolicy{`,
		`Labels:` + mapStringForLabels + `,`,
		`Backoff:` + strings.Replace(strings.Replace(this.Backoff.String(), "Backoff", "Backoff", 1), `&`, ``, 1) + `,`,
		`ErrorOnBackoffTimeout:` + fmt.Sprintf("%v", this.ErrorOnBackoffTimeout) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KafkaTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	s := strings.Join([]string{`&KafkaTrigger{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`RequiredAcks:` + fmt.Sprintf("%v", this.RequiredAcks) + `,`,
		`Compress:` + fmt.Sprintf("%v", this.Compress) + `,`,
		`FlushFrequency:` + fmt.Sprintf("%v", this.FlushFrequency) + `,`,
		`TLS:` + strings.Replace(this.TLS.String(), "TLSConfig", "TLSConfig", 1) + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`PartitioningKey:` + fmt.Sprintf("%v", this.PartitioningKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NATSSubscription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NATSSubscription{`,
		`ServerURL:` + fmt.Sprintf("%v", this.ServerURL) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NATSTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&NATSTrigger{`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`Subject:` + fmt.Sprintf("%v", this.Subject) + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`TLS:` + strings.Replace(this.TLS.String(), "TLSConfig", "TLSConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeStatus{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`StartedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.StartedAt), "MicroTime", "v11.MicroTime", 1), `&`, ``, 1) + `,`,
		`CompletedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CompletedAt), "MicroTime", "v11.MicroTime", 1), `&`, ``, 1) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Event:` + strings.Replace(this.Event.String(), "Event", "Event", 1) + `,`,
		`UpdatedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.UpdatedAt), "MicroTime", "v11.MicroTime", 1), `&`, ``, 1) + `,`,
		`ResolvedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ResolvedAt), "MicroTime", "v11.MicroTime", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenWhiskTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPayload := "[]TriggerParameter{"
	for _, f := range this.Payload {
		repeatedStringForPayload += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPayload += "}"
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&OpenWhiskTrigger{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`AuthToken:` + strings.Replace(fmt.Sprintf("%v", this.AuthToken), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`ActionName:` + fmt.Sprintf("%v", this.ActionName) + `,`,
		`Payload:` + repeatedStringForPayload + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`}`,
	}, "")
	return s
}
func (this *S3Artifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S3Artifact{`,
		`Endpoint:` + fmt.Sprintf("%v", this.Endpoint) + `,`,
		`Bucket:` + strings.Replace(this.Bucket.String(), "S3Bucket", "S3Bucket", 1) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Insecure:` + fmt.Sprintf("%v", this.Insecure) + `,`,
		`AccessKey:` + strings.Replace(fmt.Sprintf("%v", this.AccessKey), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`SecretKey:` + strings.Replace(fmt.Sprintf("%v", this.SecretKey), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Events:` + fmt.Sprintf("%v", this.Events) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "S3Filter", "S3Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S3Bucket) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S3Bucket{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S3Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S3Filter{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`Suffix:` + fmt.Sprintf("%v", this.Suffix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sensor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sensor{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v11.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "SensorSpec", "SensorSpec", 1), `&`, ``, 1) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "SensorStatus", "SensorStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SensorList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]Sensor{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "Sensor", "Sensor", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&SensorList{`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v11.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *SensorResources) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SensorResources{`,
		`Deployment:` + strings.Replace(fmt.Sprintf("%v", this.Deployment), "ObjectMeta", "v11.ObjectMeta", 1) + `,`,
		`Service:` + strings.Replace(fmt.Sprintf("%v", this.Service), "ObjectMeta", "v11.ObjectMeta", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SensorSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDependencies := "[]EventDependency{"
	for _, f := range this.Dependencies {
		repeatedStringForDependencies += strings.Replace(strings.Replace(f.String(), "EventDependency", "EventDependency", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDependencies += "}"
	repeatedStringForTriggers := "[]Trigger{"
	for _, f := range this.Triggers {
		repeatedStringForTriggers += strings.Replace(strings.Replace(f.String(), "Trigger", "Trigger", 1), `&`, ``, 1) + ","
	}
	repeatedStringForTriggers += "}"
	repeatedStringForDependencyGroups := "[]DependencyGroup{"
	for _, f := range this.DependencyGroups {
		repeatedStringForDependencyGroups += strings.Replace(strings.Replace(f.String(), "DependencyGroup", "DependencyGroup", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDependencyGroups += "}"
	keysForServiceAnnotations := make([]string, 0, len(this.ServiceAnnotations))
	for k := range this.ServiceAnnotations {
		keysForServiceAnnotations = append(keysForServiceAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForServiceAnnotations)
	mapStringForServiceAnnotations := "map[string]string{"
	for _, k := range keysForServiceAnnotations {
		mapStringForServiceAnnotations += fmt.Sprintf("%v: %v,", k, this.ServiceAnnotations[k])
	}
	mapStringForServiceAnnotations += "}"
	keysForServiceLabels := make([]string, 0, len(this.ServiceLabels))
	for k := range this.ServiceLabels {
		keysForServiceLabels = append(keysForServiceLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForServiceLabels)
	mapStringForServiceLabels := "map[string]string{"
	for _, k := range keysForServiceLabels {
		mapStringForServiceLabels += fmt.Sprintf("%v: %v,", k, this.ServiceLabels[k])
	}
	mapStringForServiceLabels += "}"
	s := strings.Join([]string{`&SensorSpec{`,
		`Dependencies:` + repeatedStringForDependencies + `,`,
		`Triggers:` + repeatedStringForTriggers + `,`,
		`Template:` + strings.Replace(strings.Replace(this.Template.String(), "Template", "Template", 1), `&`, ``, 1) + `,`,
		`Subscription:` + strings.Replace(this.Subscription.String(), "Subscription", "Subscription", 1) + `,`,
		`Circuit:` + fmt.Sprintf("%v", this.Circuit) + `,`,
		`DependencyGroups:` + repeatedStringForDependencyGroups + `,`,
		`ErrorOnFailedRound:` + fmt.Sprintf("%v", this.ErrorOnFailedRound) + `,`,
		`ServiceAnnotations:` + mapStringForServiceAnnotations + `,`,
		`ServiceLabels:` + mapStringForServiceLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *SensorStatus) String() string {
	if this == nil {
		return "nil"
	}
	keysForNodes := make([]string, 0, len(this.Nodes))
	for k := range this.Nodes {
		keysForNodes = append(keysForNodes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNodes)
	mapStringForNodes := "map[string]NodeStatus{"
	for _, k := range keysForNodes {
		mapStringForNodes += fmt.Sprintf("%v: %v,", k, this.Nodes[k])
	}
	mapStringForNodes += "}"
	s := strings.Join([]string{`&SensorStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`StartedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.StartedAt), "Time", "v11.Time", 1), `&`, ``, 1) + `,`,
		`CompletedAt:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CompletedAt), "Time", "v11.Time", 1), `&`, ``, 1) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Nodes:` + mapStringForNodes + `,`,
		`TriggerCycleCount:` + fmt.Sprintf("%v", this.TriggerCycleCount) + `,`,
		`TriggerCycleStatus:` + fmt.Sprintf("%v", this.TriggerCycleStatus) + `,`,
		`LastCycleTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastCycleTime), "Time", "v11.Time", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(this.Resources.String(), "SensorResources", "SensorResources", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlackTrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&SlackTrigger{`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`SlackToken:` + strings.Replace(fmt.Sprintf("%v", this.SlackToken), "SecretKeySelector", "v1.SecretKeySelector", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StandardK8STrigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&StandardK8STrigger{`,
		`GroupVersionResource:` + strings.Replace(fmt.Sprintf("%v", this.GroupVersionResource), "GroupVersionResource", "v11.GroupVersionResource", 1) + `,`,
		`Source:` + strings.Replace(this.Source.String(), "ArtifactLocation", "ArtifactLocation", 1) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`PatchStrategy:` + fmt.Sprintf("%v", this.PatchStrategy) + `,`,
		`LiveObject:` + fmt.Sprintf("%v", this.LiveObject) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusPolicy{`,
		`Allow:` + fmt.Sprintf("%v", this.Allow) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Subscription) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Subscription{`,
		`HTTP:` + strings.Replace(this.HTTP.String(), "HTTPSubscription", "HTTPSubscription", 1) + `,`,
		`NATS:` + strings.Replace(this.NATS.String(), "NATSSubscription", "NATSSubscription", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TLSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TLSConfig{`,
		`CACertPath:` + fmt.Sprintf("%v", this.CACertPath) + `,`,
		`ClientCertPath:` + fmt.Sprintf("%v", this.ClientCertPath) + `,`,
		`ClientKeyPath:` + fmt.Sprintf("%v", this.ClientKeyPath) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Template) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVolumes := "[]Volume{"
	for _, f := range this.Volumes {
		repeatedStringForVolumes += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForVolumes += "}"
	s := strings.Join([]string{`&Template{`,
		`ServiceAccountName:` + fmt.Sprintf("%v", this.ServiceAccountName) + `,`,
		`Container:` + strings.Replace(fmt.Sprintf("%v", this.Container), "Container", "v1.Container", 1) + `,`,
		`Volumes:` + repeatedStringForVolumes + `,`,
		`SecurityContext:` + strings.Replace(fmt.Sprintf("%v", this.SecurityContext), "PodSecurityContext", "v1.PodSecurityContext", 1) + `,`,
		`Spec:` + strings.Replace(fmt.Sprintf("%v", this.Spec), "PodSpec", "v1.PodSpec", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeFilter{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`Stop:` + fmt.Sprintf("%v", this.Stop) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Trigger) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForParameters := "[]TriggerParameter{"
	for _, f := range this.Parameters {
		repeatedStringForParameters += strings.Replace(strings.Replace(f.String(), "TriggerParameter", "TriggerParameter", 1), `&`, ``, 1) + ","
	}
	repeatedStringForParameters += "}"
	s := strings.Join([]string{`&Trigger{`,
		`Template:` + strings.Replace(this.Template.String(), "TriggerTemplate", "TriggerTemplate", 1) + `,`,
		`Parameters:` + repeatedStringForParameters + `,`,
		`Policy:` + strings.Replace(this.Policy.String(), "TriggerPolicy", "TriggerPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerParameter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerParameter{`,
		`Src:` + strings.Replace(this.Src.String(), "TriggerParameterSource", "TriggerParameterSource", 1) + `,`,
		`Dest:` + fmt.Sprintf("%v", this.Dest) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerParameterSource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerParameterSource{`,
		`DependencyName:` + fmt.Sprintf("%v", this.DependencyName) + `,`,
		`ContextKey:` + fmt.Sprintf("%v", this.ContextKey) + `,`,
		`ContextTemplate:` + fmt.Sprintf("%v", this.ContextTemplate) + `,`,
		`DataTemplate:` + fmt.Sprintf("%v", this.DataTemplate) + `,`,
		`Value:` + valueToStringGenerated(this.Value) + `,`,
		`DataKey:` + fmt.Sprintf("%v", this.DataKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerPolicy{`,
		`K8s:` + strings.Replace(fmt.Sprintf("%v", this.K8s), "K8SResourcePolicy", "K8SResourcePolicy", 1) + `,`,
		`Status:` + strings.Replace(this.Status.String(), "StatusPolicy", "StatusPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerSwitch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerSwitch{`,
		`Any:` + fmt.Sprintf("%v", this.Any) + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TriggerTemplate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TriggerTemplate{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Switch:` + strings.Replace(this.Switch.String(), "TriggerSwitch", "TriggerSwitch", 1) + `,`,
		`K8s:` + strings.Replace(fmt.Sprintf("%v", this.K8s), "StandardK8STrigger", "StandardK8STrigger", 1) + `,`,
		`ArgoWorkflow:` + strings.Replace(this.ArgoWorkflow.String(), "ArgoWorkflowTrigger", "ArgoWorkflowTrigger", 1) + `,`,
		`HTTP:` + strings.Replace(this.HTTP.String(), "HTTPTrigger", "HTTPTrigger", 1) + `,`,
		`AWSLambda:` + strings.Replace(this.AWSLambda.String(), "AWSLambdaTrigger", "AWSLambdaTrigger", 1) + `,`,
		`CustomTrigger:` + strings.Replace(this.CustomTrigger.String(), "CustomTrigger", "CustomTrigger", 1) + `,`,
		`Kafka:` + strings.Replace(this.Kafka.String(), "KafkaTrigger", "KafkaTrigger", 1) + `,`,
		`NATS:` + strings.Replace(this.NATS.String(), "NATSTrigger", "NATSTrigger", 1) + `,`,
		`Slack:` + strings.Replace(this.Slack.String(), "SlackTrigger", "SlackTrigger", 1) + `,`,
		`OpenWhisk:` + strings.Replace(this.OpenWhisk.String(), "OpenWhiskTrigger", "OpenWhiskTrigger", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URLArtifact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URLArtifact{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`VerifyCert:` + fmt.Sprintf("%v", this.VerifyCert) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGenerated(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSLambdaTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSLambdaTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSLambdaTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessKey == nil {
				m.AccessKey = &v1.SecretKeySelector{}
			}
			if err := m.AccessKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKey == nil {
				m.SecretKey = &v1.SecretKeySelector{}
			}
			if err := m.SecretKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgoWorkflowTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgoWorkflowTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgoWorkflowTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ArtifactLocation{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = ArgoWorkflowOperation(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersionResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GroupVersionResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArtifactLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArtifactLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArtifactLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.S3 == nil {
				m.S3 = &S3Artifact{}
			}
			if err := m.S3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Inline = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &FileArtifact{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URL == nil {
				m.URL = &URLArtifact{}
			}
			if err := m.URL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configmap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configmap == nil {
				m.Configmap = &ConfigmapArtifact{}
			}
			if err := m.Configmap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitArtifact{}
			}
			if err := m.Git.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource[:0], dAtA[iNdEx:postIndex]...)
			if m.Resource == nil {
				m.Resource = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Backoff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Backoff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Backoff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Factor = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jitter", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Jitter = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			m.Steps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Steps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Username == nil {
				m.Username = &v1.SecretKeySelector{}
			}
			if err := m.Username.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &v1.SecretKeySelector{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigmapArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigmapArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigmapArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Secure = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNameOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNameOverride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Spec[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = JSONType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comparator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comparator = Comparator(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DependencyGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DependencyGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DependencyGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &EventContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &EventDependencyFilter{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDependencyFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDependencyFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDependencyFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &TimeFilter{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &EventContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, DataFilter{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloneDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloneDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &GitCreds{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHKeyPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHKeyPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Remote == nil {
				m.Remote = &GitRemoteConfig{}
			}
			if err := m.Remote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Username == nil {
				m.Username = &v1.SecretKeySelector{}
			}
			if err := m.Username.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &v1.SecretKeySelector{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitRemoteConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitRemoteConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitRemoteConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLS = append(m.URLS, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPSubscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPSubscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLS == nil {
				m.TLS = &TLSConfig{}
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicAuth == nil {
				m.BasicAuth = &BasicAuth{}
			}
			if err := m.BasicAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SResourcePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sResourcePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sResourcePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backoff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Backoff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorOnBackoffTimeout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorOnBackoffTimeout = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KafkaTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredAcks", wireType)
			}
			m.RequiredAcks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredAcks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compress = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushFrequency", wireType)
			}
			m.FlushFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushFrequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLS == nil {
				m.TLS = &TLSConfig{}
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitioningKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitioningKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NATSSubscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NATSSubscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NATSSubscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NATSTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NATSTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NATSTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLS == nil {
				m.TLS = &TLSConfig{}
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = NodeType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = NodePhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolvedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenWhiskTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenWhiskTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenWhiskTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthToken == nil {
				m.AuthToken = &v1.SecretKeySelector{}
			}
			if err := m.AuthToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, TriggerParameter{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &S3Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Insecure = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessKey == nil {
				m.AccessKey = &v1.SecretKeySelector{}
			}
			if err := m.AccessKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKey == nil {
				m.SecretKey = &v1.SecretKeySelector{}
			}
			if err := m.SecretKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &S3Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sensor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sensor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sensor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, Sensor{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &v11.ObjectMeta{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &v11.ObjectMeta{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, EventDependency{})
			if err := m.Dependencies[len(m.Dependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Triggers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Triggers = append(m.Triggers, Trigger{})
			if err := m.Triggers[len(m.Triggers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Template.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Circuit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Circuit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependencyGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DependencyGroups = append(m.DependencyGroups, DependencyGroup{})
			if err := m.DependencyGroups[len(m.DependencyGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorOnFailedRound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorOnFailedRound = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceAnnotations == nil {
				m.ServiceAnnotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceAnnotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceLabels == nil {
				m.ServiceLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = NodePhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CompletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[string]NodeStatus)
			}
			var mapkey string
			mapvalue := &NodeStatus{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGenerated
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGenerated
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NodeStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[mapkey] = *mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerCycleCount", wireType)
			}
			m.TriggerCycleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerCycleCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerCycleStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerCycleStatus = TriggerCycleState(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCycleTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCycleTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &SensorResources{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlackTrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlackTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlackTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlackToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlackToken == nil {
				m.SlackToken = &v1.SecretKeySelector{}
			}
			if err := m.SlackToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StandardK8STrigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StandardK8sTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StandardK8sTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersionResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupVersionResource == nil {
				m.GroupVersionResource = &v11.GroupVersionResource{}
			}
			if err := m.GroupVersionResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &ArtifactLocation{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = KubernetesResourceOperation(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatchStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatchStrategy = k8s_io_apimachinery_pkg_types.PatchType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveObject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LiveObject = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Allow = append(m.Allow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGenerated
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGenerated
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Allow) == 0 {
					m.Allow = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Allow = append(m.Allow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTTP == nil {
				m.HTTP = &HTTPSubscription{}
			}
			if err := m.HTTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NATS == nil {
				m.NATS = &NATSSubscription{}
			}
			if err := m.NATS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACertPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACertPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeyPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientKeyPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Template) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Template: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Template: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &v1.Container{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, v1.Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityContext == nil {
				m.SecurityContext = &v1.PodSecurityContext{}
			}
			if err := m.SecurityContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &v1.PodSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = &TriggerTemplate{}
			}
			if err := m.Template.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, TriggerParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &TriggerPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &TriggerParameterSource{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = TriggerParameterOperation(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerParameterSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerParameterSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerParameterSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependencyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DependencyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTemplate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataTemplate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8s", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8s == nil {
				m.K8s = &K8SResourcePolicy{}
			}
			if err := m.K8s.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &StatusPolicy{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerSwitch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerSwitch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerSwitch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Any = append(m.Any, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.All = append(m.All, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Switch == nil {
				m.Switch = &TriggerSwitch{}
			}
			if err := m.Switch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8s", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8s == nil {
				m.K8s = &StandardK8STrigger{}
			}
			if err := m.K8s.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgoWorkflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArgoWorkflow == nil {
				m.ArgoWorkflow = &ArgoWorkflowTrigger{}
			}
			if err := m.ArgoWorkflow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTTP == nil {
				m.HTTP = &HTTPTrigger{}
			}
			if err := m.HTTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSLambda", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AWSLambda == nil {
				m.AWSLambda = &AWSLambdaTrigger{}
			}
			if err := m.AWSLambda.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomTrigger == nil {
				m.CustomTrigger = &CustomTrigger{}
			}
			if err := m.CustomTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kafka", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kafka == nil {
				m.Kafka = &KafkaTrigger{}
			}
			if err := m.Kafka.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NATS == nil {
				m.NATS = &NATSTrigger{}
			}
			if err := m.NATS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Slack == nil {
				m.Slack = &SlackTrigger{}
			}
			if err := m.Slack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenWhisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenWhisk == nil {
				m.OpenWhisk = &OpenWhiskTrigger{}
			}
			if err := m.OpenWhisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLArtifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLArtifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLArtifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyCert = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
