{
  "swagger": "2.0",
  "info": {
    "title": "Argo Events",
    "version": "v0.16.0"
  },
  "paths": {},
  "definitions": {
    "io.argoproj.common.Amount": {
      "description": "Amount represent a numeric amount.",
      "type": "number"
    },
    "io.argoproj.common.Backoff": {
      "description": "Backoff for an operation",
      "type": "object",
      "required": [
        "duration",
        "factor"
      ],
      "properties": {
        "duration": {
          "description": "Duration is the duration in nanoseconds",
          "type": "integer",
          "format": "int64"
        },
        "factor": {
          "description": "Duration is multiplied by factor each iteration",
          "$ref": "#/definitions/io.argoproj.common.Amount"
        },
        "jitter": {
          "description": "The amount of jitter applied each iteration",
          "$ref": "#/definitions/io.argoproj.common.Amount"
        },
        "steps": {
          "description": "Exit with error after this many steps",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.argoproj.common.Condition": {
      "description": "Condition contains details about resource state",
      "type": "object",
      "required": [
        "type",
        "status"
      ],
      "properties": {
        "lastTransitionTime": {
          "description": "Last time the condition transitioned from one status to another.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Human-readable message indicating details about last transition.",
          "type": "string"
        },
        "reason": {
          "description": "Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. For example, \"ImageNotFound\"",
          "type": "string"
        },
        "status": {
          "description": "Condition status, True, False or Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Condition type.",
          "type": "string"
        }
      }
    },
    "io.argoproj.common.Resource": {
      "description": "Resource represent arbitrary structured data.",
      "type": "object"
    },
    "io.argoproj.common.S3Artifact": {
      "description": "S3Artifact contains information about an S3 connection and bucket",
      "type": "object",
      "required": [
        "endpoint",
        "bucket",
        "accessKey",
        "secretKey"
      ],
      "properties": {
        "accessKey": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "bucket": {
          "$ref": "#/definitions/io.argoproj.common.S3Bucket"
        },
        "endpoint": {
          "type": "string"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "filter": {
          "$ref": "#/definitions/io.argoproj.common.S3Filter"
        },
        "insecure": {
          "type": "boolean"
        },
        "region": {
          "type": "string"
        },
        "secretKey": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.common.S3Bucket": {
      "description": "S3Bucket contains information to describe an S3 Bucket",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "key": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "io.argoproj.common.S3Filter": {
      "description": "S3Filter represents filters to apply to bucket nofifications for specifying constraints on objects",
      "type": "object",
      "required": [
        "prefix",
        "suffix"
      ],
      "properties": {
        "prefix": {
          "type": "string"
        },
        "suffix": {
          "type": "string"
        }
      }
    },
    "io.argoproj.common.Status": {
      "description": "Status is a common structure which can be used for Status field.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Conditions are the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.common.Condition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.BusConfig": {
      "description": "BusConfig has the finalized configuration for EventBus",
      "type": "object",
      "properties": {
        "nats": {
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.NATSConfig"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.EventBus": {
      "description": "EventBus is the definition of a eventbus resource",
      "type": "object",
      "required": [
        "metadata",
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.EventBusSpec"
        },
        "status": {
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.EventBusStatus"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.EventBusList": {
      "description": "EventBusList is the list of eventbus resources",
      "type": "object",
      "required": [
        "metadata",
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.EventBus"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.EventBusSpec": {
      "description": "EventBusSpec refers to specification of eventbus resource",
      "type": "object",
      "properties": {
        "nats": {
          "description": "NATS eventbus",
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.NATSBus"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.EventBusStatus": {
      "description": "EventBusStatus holds the status of the eventbus resource",
      "type": "object",
      "properties": {
        "config": {
          "description": "Config holds the fininalized configuration of EventBus",
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.BusConfig"
        },
        "status": {
          "$ref": "#/definitions/io.argoproj.common.Status"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.NATSBus": {
      "description": "NATSBus holds the NATS eventbus information",
      "type": "object",
      "properties": {
        "exotic": {
          "description": "Exotic holds an exotic NATS config",
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.NATSConfig"
        },
        "native": {
          "description": "Native means to bring up a native NATS service",
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.NativeStrategy"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.NATSConfig": {
      "description": "NATSConfig holds the config of NATS",
      "type": "object",
      "properties": {
        "accessSecret": {
          "description": "Secret for auth",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "auth": {
          "description": "Auth strategy, default to AuthStrategyNone",
          "type": "string"
        },
        "clusterID": {
          "description": "Cluster ID for nats streaming, if it's missing, treat it as NATS server",
          "type": "string"
        },
        "url": {
          "description": "NATS host url",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.NativeStrategy": {
      "description": "NativeStrategy indicates to install a native NATS service",
      "type": "object",
      "properties": {
        "antiAffinity": {
          "type": "boolean"
        },
        "auth": {
          "type": "string"
        },
        "persistence": {
          "$ref": "#/definitions/io.argoproj.eventbus.v1alpha1.PersistenceStrategy"
        },
        "replicas": {
          "description": "Size is the NATS StatefulSet size",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.argoproj.eventbus.v1alpha1.PersistenceStrategy": {
      "description": "PersistenceStrategy defines the strategy of persistence",
      "type": "object",
      "properties": {
        "accessMode": {
          "description": "Available access modes such as ReadWriteOnce, ReadWriteMany https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes",
          "type": "string"
        },
        "storageClassName": {
          "description": "Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
          "type": "string"
        },
        "volumeSize": {
          "description": "Volume size, e.g. 10Gi",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.AMQPEventSource": {
      "description": "AMQPEventSource refers to an event-source for AMQP stream events",
      "type": "object",
      "required": [
        "url",
        "exchangeName",
        "exchangeType",
        "routingKey"
      ],
      "properties": {
        "connectionBackoff": {
          "description": "Backoff holds parameters applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "exchangeName": {
          "description": "ExchangeName is the exchange name For more information, visit https://www.rabbitmq.com/tutorials/amqp-concepts.html",
          "type": "string"
        },
        "exchangeType": {
          "description": "ExchangeType is rabbitmq exchange type",
          "type": "string"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "routingKey": {
          "description": "Routing key for bindings",
          "type": "string"
        },
        "tls": {
          "description": "TLS configuration for the amqp client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "url": {
          "description": "URL for rabbitmq service",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.AzureEventsHubEventSource": {
      "description": "AzureEventsHubEventSource describes the event source for azure events hub More info at https://docs.microsoft.com/en-us/azure/event-hubs/",
      "type": "object",
      "required": [
        "fqdn",
        "hubName"
      ],
      "properties": {
        "fqdn": {
          "description": "FQDN of the EventHubs namespace you created More info at https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string",
          "type": "string"
        },
        "hubName": {
          "description": "Event Hub path/name",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace which is used to retrieve the shared access key and name from.",
          "type": "string"
        },
        "sharedAccessKey": {
          "description": "SharedAccessKey is the the generated value of the key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "sharedAccessKeyName": {
          "description": "SharedAccessKeyName is the name you chose for your application's SAS keys",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.CalendarEventSource": {
      "description": "CalendarEventSource describes a time based dependency. One of the fields (schedule, interval, or recurrence) must be passed. Schedule takes precedence over interval; interval takes precedence over recurrence",
      "type": "object",
      "required": [
        "schedule",
        "interval"
      ],
      "properties": {
        "exclusionDates": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "interval": {
          "description": "Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...",
          "type": "string"
        },
        "schedule": {
          "description": "Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron",
          "type": "string"
        },
        "timezone": {
          "description": "Timezone in which to run the schedule",
          "type": "string"
        },
        "userPayload": {
          "description": "UserPayload will be sent to sensor as extra data once the event is triggered",
          "type": "string",
          "format": "byte"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.EmitterEventSource": {
      "description": "EmitterEventSource describes the event source for emitter More info at https://emitter.io/develop/getting-started/",
      "type": "object",
      "required": [
        "broker",
        "channelKey",
        "channelName"
      ],
      "properties": {
        "broker": {
          "description": "Broker URI to connect to.",
          "type": "string"
        },
        "channelKey": {
          "description": "ChannelKey refers to the channel key",
          "type": "string"
        },
        "channelName": {
          "description": "ChannelName refers to the channel name",
          "type": "string"
        },
        "connectionBackoff": {
          "description": "Backoff holds parameters applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "namespace": {
          "description": "Namespace to use to retrieve the channel key and optional username/password",
          "type": "string"
        },
        "password": {
          "description": "Password to use to connect to broker",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "tls": {
          "description": "TLS configuration for the emitter client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "username": {
          "description": "Username to use to connect to broker",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.EventSource": {
      "description": "EventSource is the definition of a eventsource resource",
      "type": "object",
      "required": [
        "metadata",
        "status",
        "spec"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.EventSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.EventSourceStatus"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.EventSourceList": {
      "description": "EventSourceList is the list of eventsource resources",
      "type": "object",
      "required": [
        "metadata",
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.EventSource"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.EventSourceSpec": {
      "description": "EventSourceSpec refers to specification of event-source resource",
      "type": "object",
      "properties": {
        "amqp": {
          "description": "AMQP event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.AMQPEventSource"
          }
        },
        "azureEventsHub": {
          "description": "AzureEventsHub event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.AzureEventsHubEventSource"
          }
        },
        "calendar": {
          "description": "Calendar event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.CalendarEventSource"
          }
        },
        "emitter": {
          "description": "Emitter event source",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.EmitterEventSource"
          }
        },
        "file": {
          "description": "File event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.FileEventSource"
          }
        },
        "generic": {
          "description": "Generic event source",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.GenericEventSource"
          }
        },
        "github": {
          "description": "Github event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.GithubEventSource"
          }
        },
        "gitlab": {
          "description": "Gitlab event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.GitlabEventSource"
          }
        },
        "hdfs": {
          "description": "HDFS event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.HDFSEventSource"
          }
        },
        "kafka": {
          "description": "Kafka event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.KafkaEventSource"
          }
        },
        "minio": {
          "description": "Minio event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.common.S3Artifact"
          }
        },
        "mqtt": {
          "description": "MQTT event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.MQTTEventSource"
          }
        },
        "nats": {
          "description": "NATS event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.NATSEventsSource"
          }
        },
        "nsq": {
          "description": "NSQ event source",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.NSQEventSource"
          }
        },
        "pubSub": {
          "description": "PubSub eevnt sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.PubSubEventSource"
          }
        },
        "redis": {
          "description": "Redis event source",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.RedisEventSource"
          }
        },
        "resource": {
          "description": "Resource event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.ResourceEventSource"
          }
        },
        "slack": {
          "description": "Slack event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.SlackEventSource"
          }
        },
        "sns": {
          "description": "SNS event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.SNSEventSource"
          }
        },
        "sqs": {
          "description": "SQS event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.SQSEventSource"
          }
        },
        "storageGrid": {
          "description": "StorageGrid event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.StorageGridEventSource"
          }
        },
        "stripe": {
          "description": "Stripe event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.StripeEventSource"
          }
        },
        "webhook": {
          "description": "Webhook event sources",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
          }
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.EventSourceStatus": {
      "description": "EventSourceStatus holds the status of the event-source resource",
      "type": "object",
      "properties": {
        "createdAt": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.FileEventSource": {
      "description": "FileEventSource describes an event-source for file related events.",
      "type": "object",
      "required": [
        "eventType",
        "watchPathConfig"
      ],
      "properties": {
        "eventType": {
          "description": "Type of file operations to watch Refer https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information",
          "type": "string"
        },
        "polling": {
          "description": "Use polling instead of inotify",
          "type": "boolean"
        },
        "watchPathConfig": {
          "description": "WatchPathConfig contains configuration about the file path to watch",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WatchPathConfig"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.GenericEventSource": {
      "description": "GenericEventSource refers to a generic event source. It can be used to implement a custom event source.",
      "type": "object",
      "required": [
        "value"
      ],
      "properties": {
        "value": {
          "description": "Value of the event source",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.GithubEventSource": {
      "description": "GithubEventSource refers to event-source for github related events",
      "type": "object",
      "required": [
        "id",
        "owner",
        "repository",
        "events"
      ],
      "properties": {
        "active": {
          "description": "Active refers to status of the webhook for event deliveries. https://developer.github.com/webhooks/creating/#active",
          "type": "boolean"
        },
        "apiToken": {
          "description": "APIToken refers to a K8s secret containing github api token",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "contentType": {
          "description": "ContentType of the event delivery",
          "type": "string"
        },
        "deleteHookOnFinish": {
          "description": "DeleteHookOnFinish determines whether to delete the GitHub hook for the repository once the event source is stopped.",
          "type": "boolean"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "githubBaseURL": {
          "description": "GitHub base URL (for GitHub Enterprise)",
          "type": "string"
        },
        "githubUploadURL": {
          "description": "GitHub upload URL (for GitHub Enterprise)",
          "type": "string"
        },
        "id": {
          "description": "Id is the webhook's id",
          "type": "integer",
          "format": "int64"
        },
        "insecure": {
          "description": "Insecure tls verification",
          "type": "boolean"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace which is used to retrieve webhook secret and api token from.",
          "type": "string"
        },
        "owner": {
          "description": "Owner refers to GitHub owner name i.e. argoproj",
          "type": "string"
        },
        "repository": {
          "description": "Repository refers to GitHub repo name i.e. argo-events",
          "type": "string"
        },
        "webhook": {
          "description": "Webhook refers to the configuration required to run a http server",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        },
        "webhookSecret": {
          "description": "WebhookSecret refers to K8s secret containing GitHub webhook secret https://developer.github.com/webhooks/securing/",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.GitlabEventSource": {
      "description": "GitlabEventSource refers to event-source related to Gitlab events",
      "type": "object",
      "required": [
        "projectID",
        "events",
        "gitlabBaseURL"
      ],
      "properties": {
        "accessToken": {
          "description": "AccessToken is reference to k8 secret which holds the gitlab api access information",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "deleteHookOnFinish": {
          "description": "DeleteHookOnFinish determines whether to delete the GitLab hook for the project once the event source is stopped.",
          "type": "boolean"
        },
        "enableSSLVerification": {
          "description": "EnableSSLVerification to enable ssl verification",
          "type": "boolean"
        },
        "events": {
          "description": "Events are gitlab event to listen to. Refer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "gitlabBaseURL": {
          "description": "GitlabBaseURL is the base URL for API requests to a custom endpoint",
          "type": "string"
        },
        "projectID": {
          "description": "ProjectID is the id of project for which integration needs to setup",
          "type": "string"
        },
        "webhook": {
          "description": "Webhook holds configuration to run a http server",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.HDFSEventSource": {
      "description": "HDFSEventSource refers to event-source for HDFS related events",
      "type": "object",
      "required": [
        "directory",
        "type",
        "addresses"
      ],
      "properties": {
        "addresses": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "checkInterval": {
          "description": "CheckInterval is a string that describes an interval duration to check the directory state, e.g. 1s, 30m, 2h... (defaults to 1m)",
          "type": "string"
        },
        "directory": {
          "description": "Directory to watch for events",
          "type": "string"
        },
        "hdfsUser": {
          "description": "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.",
          "type": "string"
        },
        "krbCCacheSecret": {
          "description": "KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "krbConfigConfigMap": {
          "description": "KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ConfigMapKeySelector"
        },
        "krbKeytabSecret": {
          "description": "KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "krbRealm": {
          "description": "KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.",
          "type": "string"
        },
        "krbServicePrincipalName": {
          "description": "KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.",
          "type": "string"
        },
        "krbUsername": {
          "description": "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace which is used to retrieve cache secret and ket tab secret from.",
          "type": "string"
        },
        "path": {
          "description": "Path is relative path of object to watch with respect to the directory",
          "type": "string"
        },
        "pathRegexp": {
          "description": "PathRegexp is regexp of relative path of object to watch with respect to the directory",
          "type": "string"
        },
        "type": {
          "description": "Type of file operations to watch",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.KafkaEventSource": {
      "description": "KafkaEventSource refers to event-source for Kafka related events",
      "type": "object",
      "required": [
        "url",
        "partition",
        "topic"
      ],
      "properties": {
        "connectionBackoff": {
          "description": "Backoff holds parameters applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "partition": {
          "description": "Partition name",
          "type": "string"
        },
        "tls": {
          "description": "TLS configuration for the kafka client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "topic": {
          "description": "Topic name",
          "type": "string"
        },
        "url": {
          "description": "URL to kafka cluster",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.MQTTEventSource": {
      "description": "MQTTEventSource refers to event-source for MQTT related events",
      "type": "object",
      "required": [
        "url",
        "topic",
        "clientId"
      ],
      "properties": {
        "clientId": {
          "description": "ClientID is the id of the client",
          "type": "string"
        },
        "connectionBackoff": {
          "description": "ConnectionBackoff holds backoff applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "tls": {
          "description": "TLS configuration for the mqtt client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "topic": {
          "description": "Topic name",
          "type": "string"
        },
        "url": {
          "description": "URL to connect to broker",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.NATSEventsSource": {
      "description": "NATSEventSource refers to event-source for NATS related events",
      "type": "object",
      "required": [
        "url",
        "subject"
      ],
      "properties": {
        "connectionBackoff": {
          "description": "ConnectionBackoff holds backoff applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "subject": {
          "description": "Subject holds the name of the subject onto which messages are published",
          "type": "string"
        },
        "tls": {
          "description": "TLS configuration for the nats client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "url": {
          "description": "URL to connect to NATS cluster",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.NSQEventSource": {
      "description": "NSQEventSource describes the event source for NSQ PubSub More info at https://godoc.org/github.com/nsqio/go-nsq",
      "type": "object",
      "required": [
        "hostAddress",
        "topic",
        "channel"
      ],
      "properties": {
        "channel": {
          "description": "Channel used for subscription",
          "type": "string"
        },
        "connectionBackoff": {
          "description": "Backoff holds parameters applied to connection.",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "hostAddress": {
          "description": "HostAddress is the address of the host for NSQ lookup",
          "type": "string"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "tls": {
          "description": "TLS configuration for the nsq client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        },
        "topic": {
          "description": "Topic to subscribe to.",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.PubSubEventSource": {
      "description": "PubSubEventSource refers to event-source for GCP PubSub related events.",
      "type": "object",
      "required": [
        "projectID",
        "topicProjectID",
        "topic",
        "credentialsFile"
      ],
      "properties": {
        "credentialsFile": {
          "description": "CredentialsFile is the file that contains credentials to authenticate for GCP",
          "type": "string"
        },
        "deleteSubscriptionOnFinish": {
          "description": "DeleteSubscriptionOnFinish determines whether to delete the GCP PubSub subscription once the event source is stopped.",
          "type": "boolean"
        },
        "enableWorkflowIdentity": {
          "description": "EnableWorkflowIdentity determines if your project authenticates to GCP with WorkflowIdentity or CredentialsFile. If true, authentication is done with WorkflowIdentity. If false or omitted, authentication is done with CredentialsFile.",
          "type": "boolean"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "projectID": {
          "description": "ProjectID is the unique identifier for your project on GCP",
          "type": "string"
        },
        "topic": {
          "description": "Topic on which a subscription will be created",
          "type": "string"
        },
        "topicProjectID": {
          "description": "TopicProjectID identifies the project where the topic should exist or be created (assumed to be the same as ProjectID by default)",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.RedisEventSource": {
      "description": "RedisEventSource describes an event source for the Redis PubSub. More info at https://godoc.org/github.com/go-redis/redis#example-PubSub",
      "type": "object",
      "required": [
        "hostAddress",
        "channels"
      ],
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "db": {
          "description": "DB to use. If not specified, default DB 0 will be used.",
          "type": "integer",
          "format": "int32"
        },
        "hostAddress": {
          "description": "HostAddress refers to the address of the Redis host/server",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace to use to retrieve the password from. It should only be specified if password is declared",
          "type": "string"
        },
        "password": {
          "description": "Password required for authentication if any.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "tls": {
          "description": "TLS configuration for the redis client.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.TLSConfig"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.ResourceEventSource": {
      "description": "ResourceEventSource refers to a event-source for K8s resource related events.",
      "type": "object",
      "required": [
        "namespace",
        "group",
        "version",
        "resource",
        "eventTypes"
      ],
      "properties": {
        "eventTypes": {
          "description": "EventTypes is the list of event type to watch. Possible values are - ADD, UPDATE and DELETE.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "filter": {
          "description": "Filter is applied on the metadata of the resource If you apply filter, then the internal event informer will only monitor objects that pass the filter.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.ResourceFilter"
        },
        "group": {
          "type": "string"
        },
        "namespace": {
          "description": "Namespace where resource is deployed",
          "type": "string"
        },
        "resource": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.ResourceFilter": {
      "description": "ResourceFilter contains K8 ObjectMeta information to further filter resource event objects",
      "type": "object",
      "properties": {
        "afterStart": {
          "description": "If the resource is created after the start time then the event is treated as valid.",
          "type": "boolean"
        },
        "createdBy": {
          "description": "If resource is created before the specified time then the event is treated as valid.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "fields": {
          "description": "Fields provide listing options to K8s API to watch resource/s. Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/ for more info.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.Selector"
          }
        },
        "labels": {
          "description": "Labels provide listing options to K8s API to watch resource/s. Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/label-selectors/ for more info.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.Selector"
          }
        },
        "prefix": {
          "description": "Prefix filter is applied on the resource name.",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.SNSEventSource": {
      "description": "SNSEventSource refers to event-source for AWS SNS related events",
      "type": "object",
      "required": [
        "topicArn",
        "region"
      ],
      "properties": {
        "accessKey": {
          "description": "AccessKey refers K8 secret containing aws access key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace to read access related secret from.",
          "type": "string"
        },
        "region": {
          "description": "Region is AWS region",
          "type": "string"
        },
        "roleARN": {
          "description": "RoleARN is the Amazon Resource Name (ARN) of the role to assume.",
          "type": "string"
        },
        "secretKey": {
          "description": "SecretKey refers K8 secret containing aws secret key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "topicArn": {
          "description": "TopicArn",
          "type": "string"
        },
        "webhook": {
          "description": "Webhook configuration for http server",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.SQSEventSource": {
      "description": "SQSEventSource refers to event-source for AWS SQS related events",
      "type": "object",
      "required": [
        "region",
        "queue",
        "waitTimeSeconds"
      ],
      "properties": {
        "accessKey": {
          "description": "AccessKey refers K8 secret containing aws access key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "jsonBody": {
          "description": "JSONBody specifies that all event body payload coming from this source will be JSON",
          "type": "boolean"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace to read access related secret from.",
          "type": "string"
        },
        "queue": {
          "description": "Queue is AWS SQS queue to listen to for messages",
          "type": "string"
        },
        "queueAccountId": {
          "description": "QueueAccountId is the ID of the account that created the queue to monitor",
          "type": "string"
        },
        "region": {
          "description": "Region is AWS region",
          "type": "string"
        },
        "roleARN": {
          "description": "RoleARN is the Amazon Resource Name (ARN) of the role to assume.",
          "type": "string"
        },
        "secretKey": {
          "description": "SecretKey refers K8 secret containing aws secret key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "waitTimeSeconds": {
          "description": "WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive in the queue before returning.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.Selector": {
      "description": "Selector represents conditional operation to select K8s objects.",
      "type": "object",
      "required": [
        "key",
        "value"
      ],
      "properties": {
        "key": {
          "description": "Key name",
          "type": "string"
        },
        "operation": {
          "description": "Supported operations like ==, !=, \u003c=, \u003e= etc. Defaults to ==. Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors for more info.",
          "type": "string"
        },
        "value": {
          "description": "Value",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.SlackEventSource": {
      "description": "SlackEventSource refers to event-source for Slack related events",
      "type": "object",
      "properties": {
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace which is used to retrieve token and signing secret from.",
          "type": "string"
        },
        "signingSecret": {
          "description": "Slack App signing secret",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "token": {
          "description": "Token for URL verification handshake",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "webhook": {
          "description": "Webhook holds configuration for a REST endpoint",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.StorageGridEventSource": {
      "description": "StorageGridEventSource refers to event-source for StorageGrid related events",
      "type": "object",
      "required": [
        "topicArn",
        "bucket",
        "authToken",
        "apiURL"
      ],
      "properties": {
        "apiURL": {
          "description": "ApiURL is the url of the storagegrid api.",
          "type": "string"
        },
        "authToken": {
          "description": "Auth token for storagegrid api",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "bucket": {
          "description": "Name of the bucket to register notifications for.",
          "type": "string"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "filter": {
          "description": "Filter on object key which caused the notification.",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.StorageGridFilter"
        },
        "region": {
          "description": "S3 region. Defaults to us-east-1",
          "type": "string"
        },
        "topicArn": {
          "description": "TopicArn",
          "type": "string"
        },
        "webhook": {
          "description": "Webhook holds configuration for a REST endpoint",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.StorageGridFilter": {
      "description": "Filter represents filters to apply to bucket notifications for specifying constraints on objects",
      "type": "object",
      "required": [
        "prefix",
        "suffix"
      ],
      "properties": {
        "prefix": {
          "type": "string"
        },
        "suffix": {
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.StripeEventSource": {
      "description": "StripeEventSource describes the event source for stripe webhook notifications More info at https://stripe.com/docs/webhooks",
      "type": "object",
      "properties": {
        "apiKey": {
          "description": "APIKey refers to K8s secret that holds Stripe API key. Used only if CreateWebhook is enabled.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "createWebhook": {
          "description": "CreateWebhook if specified creates a new webhook programmatically.",
          "type": "boolean"
        },
        "eventFilter": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "namespace": {
          "description": "Namespace to retrieve the APIKey secret from. Must be specified in order to read API key from APIKey K8s secret.",
          "type": "string"
        },
        "webhook": {
          "description": "Webhook holds configuration for a REST endpoint",
          "$ref": "#/definitions/io.argoproj.eventsource.v1alpha1.WebhookContext"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.TLSConfig": {
      "description": "TLSConfig refers to TLS configuration for a client.",
      "type": "object",
      "required": [
        "caCertPath",
        "clientCertPath",
        "clientKeyPath"
      ],
      "properties": {
        "caCertPath": {
          "description": "CACertPath refers the file path that contains the CA cert.",
          "type": "string"
        },
        "clientCertPath": {
          "description": "ClientCertPath refers the file path that contains client cert.",
          "type": "string"
        },
        "clientKeyPath": {
          "description": "ClientKeyPath refers the file path that contains client key.",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.WatchPathConfig": {
      "type": "object",
      "required": [
        "directory"
      ],
      "properties": {
        "directory": {
          "description": "Directory to watch for events",
          "type": "string"
        },
        "path": {
          "description": "Path is relative path of object to watch with respect to the directory",
          "type": "string"
        },
        "pathRegexp": {
          "description": "PathRegexp is regexp of relative path of object to watch with respect to the directory",
          "type": "string"
        }
      }
    },
    "io.argoproj.eventsource.v1alpha1.WebhookContext": {
      "description": "WebhookContext holds a general purpose REST API context",
      "type": "object",
      "required": [
        "endpoint",
        "method",
        "port",
        "url"
      ],
      "properties": {
        "endpoint": {
          "description": "REST API endpoint",
          "type": "string"
        },
        "method": {
          "description": "Method is HTTP request method that indicates the desired action to be performed for a given resource. See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
          "type": "string"
        },
        "port": {
          "description": "Port on which HTTP server is listening for incoming events.",
          "type": "string"
        },
        "serverCertPath": {
          "description": "ServerCertPath refers the file that contains the cert.",
          "type": "string"
        },
        "serverKeyPath": {
          "description": "ServerKeyPath refers the file that contains private key",
          "type": "string"
        },
        "url": {
          "description": "URL is the url of the server.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.AWSLambdaTrigger": {
      "description": "AWSLambdaTrigger refers to specification of the trigger to invoke an AWS Lambda function",
      "type": "object",
      "required": [
        "functionName",
        "region",
        "payload"
      ],
      "properties": {
        "accessKey": {
          "description": "AccessKey refers K8 secret containing aws access key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "functionName": {
          "description": "FunctionName refers to the name of the function to invoke.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace refers to Kubernetes namespace to read access related secret from. Defaults to sensor's namespace.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "region": {
          "description": "Region is AWS region",
          "type": "string"
        },
        "secretKey": {
          "description": "SecretKey refers K8 secret containing aws secret key",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.ArgoWorkflowTrigger": {
      "description": "ArgoWorkflowTrigger is the trigger for the Argo Workflow",
      "type": "object",
      "required": [
        "group",
        "version",
        "resource"
      ],
      "properties": {
        "group": {
          "type": "string"
        },
        "operation": {
          "description": "Operation refers to the type of operation performed on the argo workflow resource. Default value is Submit.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "resource": {
          "type": "string"
        },
        "source": {
          "description": "Source of the K8 resource file(s)",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.ArtifactLocation"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.ArtifactLocation": {
      "description": "ArtifactLocation describes the source location for an external artifact",
      "type": "object",
      "properties": {
        "configmap": {
          "description": "Configmap that stores the artifact",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.ConfigmapArtifact"
        },
        "file": {
          "description": "File artifact is artifact stored in a file",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.FileArtifact"
        },
        "git": {
          "description": "Git repository hosting the artifact",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.GitArtifact"
        },
        "inline": {
          "description": "Inline artifact is embedded in sensor spec as a string",
          "type": "string"
        },
        "resource": {
          "description": "Resource is generic template for K8s resource",
          "$ref": "#/definitions/io.argoproj.common.Resource"
        },
        "s3": {
          "description": "S3 compliant artifact",
          "$ref": "#/definitions/io.argoproj.common.S3Artifact"
        },
        "url": {
          "description": "URL to fetch the artifact from",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.URLArtifact"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.BasicAuth": {
      "description": "BasicAuth contains the reference to K8s secrets that holds the username and password",
      "type": "object",
      "properties": {
        "namespace": {
          "description": "Namespace to read the secrets from. Defaults to sensor's namespace.",
          "type": "string"
        },
        "password": {
          "description": "Password refers to the Kubernetes secret that holds the password required for basic auth.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "username": {
          "description": "Username refers to the Kubernetes secret that holds the username required for basic auth.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.ConfigmapArtifact": {
      "description": "ConfigmapArtifact contains information about artifact in k8 configmap",
      "type": "object",
      "required": [
        "name",
        "namespace",
        "key"
      ],
      "properties": {
        "key": {
          "description": "Key within configmap data which contains trigger resource definition",
          "type": "string"
        },
        "name": {
          "description": "Name of the configmap",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace where configmap is deployed",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.CustomTrigger": {
      "description": "CustomTrigger refers to the specification of the custom trigger.",
      "type": "object",
      "required": [
        "serverURL",
        "secure",
        "spec",
        "payload"
      ],
      "properties": {
        "certFilePath": {
          "description": "CertFilePath is path to the cert file within sensor for secure connection between sensor and custom trigger gRPC server.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "secure": {
          "description": "Secure refers to type of the connection between sensor to custom trigger gRPC",
          "type": "boolean"
        },
        "serverNameOverride": {
          "description": "ServerNameOverride for the secure connection between sensor and custom trigger gRPC server.",
          "type": "string"
        },
        "serverURL": {
          "description": "ServerURL is the url of the gRPC server that executes custom trigger",
          "type": "string"
        },
        "spec": {
          "description": "Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.DataFilter": {
      "description": "DataFilter describes constraints and filters for event data Regular Expressions are purposefully not a feature as they are overkill for our uses here See Rob Pike's Post: https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html",
      "type": "object",
      "required": [
        "path",
        "type",
        "value"
      ],
      "properties": {
        "comparator": {
          "description": "Comparator compares the event data with a user given value. Can be \"\u003e=\", \"\u003e\", \"=\", \"\u003c\", or \"\u003c=\". Is optional, and if left blank treated as equality \"=\".",
          "type": "string"
        },
        "path": {
          "description": "Path is the JSONPath of the event's (JSON decoded) data key Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'. See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
          "type": "string"
        },
        "type": {
          "description": "Type contains the JSON type of the data",
          "type": "string"
        },
        "value": {
          "description": "Value is the allowed string values for this key Booleans are passed using strconv.ParseBool() Numbers are parsed using as float64 using strconv.ParseFloat() Strings are taken as is Nils this value is ignored",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.DependencyGroup": {
      "description": "DependencyGroup is the group of dependencies",
      "type": "object",
      "required": [
        "name",
        "dependencies"
      ],
      "properties": {
        "dependencies": {
          "description": "Dependencies of events",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "name": {
          "description": "Name of the group",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.Event": {
      "description": "Event represents the cloudevent received from a gateway.",
      "type": "object",
      "required": [
        "data"
      ],
      "properties": {
        "context": {
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.EventContext"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.EventContext": {
      "description": "EventContext holds the context of the cloudevent received from a gateway.",
      "type": "object",
      "required": [
        "id",
        "source",
        "specversion",
        "type",
        "dataContentType",
        "subject",
        "time"
      ],
      "properties": {
        "dataContentType": {
          "description": "DataContentType - A MIME (RFC2046) string describing the media type of `data`.",
          "type": "string"
        },
        "id": {
          "description": "ID of the event; must be non-empty and unique within the scope of the producer.",
          "type": "string"
        },
        "source": {
          "description": "Source - A URI describing the event producer.",
          "type": "string"
        },
        "specversion": {
          "description": "SpecVersion - The version of the CloudEvents specification used by the event.",
          "type": "string"
        },
        "subject": {
          "description": "Subject - The subject of the event in the context of the event producer",
          "type": "string"
        },
        "time": {
          "description": "Time - A Timestamp when the event happened.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "type": {
          "description": "Type - The type of the occurrence which has happened.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.EventDependency": {
      "description": "EventDependency describes a dependency",
      "type": "object",
      "required": [
        "name",
        "gatewayName",
        "eventName"
      ],
      "properties": {
        "eventName": {
          "description": "EventName is the name of the event",
          "type": "string"
        },
        "filters": {
          "description": "Filters and rules governing toleration of success and constraints on the context and data of an event",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.EventDependencyFilter"
        },
        "gatewayName": {
          "description": "GatewayName is the name of the gateway from whom the event is received",
          "type": "string"
        },
        "name": {
          "description": "Name is a unique name of this dependency",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.EventDependencyFilter": {
      "description": "EventDependencyFilter defines filters and constraints for a event.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "context": {
          "description": "Context filter constraints",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.EventContext"
        },
        "data": {
          "description": "Data filter constraints with escalation",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.DataFilter"
          }
        },
        "name": {
          "description": "Name is the name of event filter",
          "type": "string"
        },
        "time": {
          "description": "Time filter on the event with escalation",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TimeFilter"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.FileArtifact": {
      "description": "FileArtifact contains information about an artifact in a filesystem",
      "type": "object",
      "properties": {
        "path": {
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.GitArtifact": {
      "description": "GitArtifact contains information about an artifact stored in git",
      "type": "object",
      "required": [
        "url",
        "cloneDirectory",
        "filePath"
      ],
      "properties": {
        "branch": {
          "description": "Branch to use to pull trigger resource",
          "type": "string"
        },
        "cloneDirectory": {
          "description": "Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers. Hence we don't use any specific git provider client.",
          "type": "string"
        },
        "creds": {
          "description": "Creds contain reference to git username and password",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.GitCreds"
        },
        "filePath": {
          "description": "Path to file that contains trigger resource definition",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace where creds are stored.",
          "type": "string"
        },
        "ref": {
          "description": "Ref to use to pull trigger resource. Will result in a shallow clone and fetch.",
          "type": "string"
        },
        "remote": {
          "description": "Remote to manage set of tracked repositories. Defaults to \"origin\". Refer https://git-scm.com/docs/git-remote",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.GitRemoteConfig"
        },
        "sshKeyPath": {
          "description": "SSHKeyPath is path to your ssh key path. Use this if you don't want to provide username and password. ssh key path must be mounted in sensor pod.",
          "type": "string"
        },
        "tag": {
          "description": "Tag to use to pull trigger resource",
          "type": "string"
        },
        "url": {
          "description": "Git URL",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.GitCreds": {
      "description": "GitCreds contain reference to git username and password",
      "type": "object",
      "properties": {
        "password": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "username": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.GitRemoteConfig": {
      "description": "GitRemoteConfig contains the configuration of a Git remote",
      "type": "object",
      "required": [
        "name",
        "urls"
      ],
      "properties": {
        "name": {
          "description": "Name of the remote to fetch from.",
          "type": "string"
        },
        "urls": {
          "description": "URLs the URLs of a remote repository. It must be non-empty. Fetch will always use the first URL, while push will use all of them.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.HTTPSubscription": {
      "description": "HTTPSubscription holds the context of the HTTP subscription of events for the sensor.",
      "type": "object",
      "required": [
        "port"
      ],
      "properties": {
        "port": {
          "description": "Port on which sensor server should run.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.HTTPTrigger": {
      "description": "HTTPTrigger is the trigger for the HTTP request",
      "type": "object",
      "required": [
        "url",
        "payload"
      ],
      "properties": {
        "basicAuth": {
          "description": "BasicAuth configuration for the http request.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.BasicAuth"
        },
        "headers": {
          "description": "Headers for the HTTP request.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "method": {
          "description": "Method refers to the type of the HTTP request. Refer https://golang.org/src/net/http/method.go for more info. Default value is POST.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "timeout": {
          "description": "Timeout refers to the HTTP request timeout in seconds. Default value is 60 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tls": {
          "description": "TLS configuration for the HTTP client.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TLSConfig"
        },
        "url": {
          "description": "URL refers to the URL to send HTTP request to.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.K8SResourcePolicy": {
      "description": "K8SResourcePolicy refers to the policy used to check the state of K8s based triggers using using labels",
      "type": "object",
      "required": [
        "backoff",
        "errorOnBackoffTimeout"
      ],
      "properties": {
        "backoff": {
          "description": "Backoff before checking resource state",
          "$ref": "#/definitions/io.argoproj.common.Backoff"
        },
        "errorOnBackoffTimeout": {
          "description": "ErrorOnBackoffTimeout determines whether sensor should transition to error state if the trigger policy is unable to determine the state of the resource",
          "type": "boolean"
        },
        "labels": {
          "description": "Labels required to identify whether a resource is in success state",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.KafkaTrigger": {
      "description": "KafkaTrigger refers to the specification of the Kafka trigger.",
      "type": "object",
      "required": [
        "url",
        "topic",
        "partition",
        "payload"
      ],
      "properties": {
        "compress": {
          "description": "Compress determines whether to compress message or not. Defaults to false. If set to true, compresses message using snappy compression.",
          "type": "boolean"
        },
        "flushFrequency": {
          "description": "FlushFrequency refers to the frequency in milliseconds to flush batches. Defaults to 500 milliseconds.",
          "type": "integer",
          "format": "int32"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "partition": {
          "description": "Partition to write data to.",
          "type": "integer",
          "format": "int32"
        },
        "partitioningKey": {
          "description": "The partitioning key for the messages put on the Kafka topic. Defaults to broker url.",
          "type": "string"
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "requiredAcks": {
          "description": "RequiredAcks used in producer to tell the broker how many replica acknowledgements Defaults to 1 (Only wait for the leader to ack).",
          "type": "integer",
          "format": "int32"
        },
        "tls": {
          "description": "TLS configuration for the Kafka producer.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TLSConfig"
        },
        "topic": {
          "description": "Name of the topic. More info at https://kafka.apache.org/documentation/#intro_topics",
          "type": "string"
        },
        "url": {
          "description": "URL of the Kafka broker.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.NATSSubscription": {
      "description": "NATSSubscription holds the context of the NATS subscription of events for the sensor",
      "type": "object",
      "required": [
        "serverURL",
        "subject"
      ],
      "properties": {
        "serverURL": {
          "description": "ServerURL refers to NATS server url.",
          "type": "string"
        },
        "subject": {
          "description": "Subject refers to NATS subject name.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.NATSTrigger": {
      "description": "NATSTrigger refers to the specification of the NATS trigger.",
      "type": "object",
      "required": [
        "url",
        "subject",
        "payload"
      ],
      "properties": {
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "subject": {
          "description": "Name of the subject to put message on.",
          "type": "string"
        },
        "tls": {
          "description": "TLS configuration for the NATS producer.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TLSConfig"
        },
        "url": {
          "description": "URL of the NATS cluster.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.NodeStatus": {
      "description": "NodeStatus describes the status for an individual node in the sensor's FSM. A single node can represent the status for event or a trigger.",
      "type": "object",
      "required": [
        "id",
        "name",
        "displayName",
        "type",
        "phase"
      ],
      "properties": {
        "completedAt": {
          "description": "CompletedAt is the time at which this node completed",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "displayName": {
          "description": "DisplayName is the human readable representation of the node",
          "type": "string"
        },
        "event": {
          "description": "Event stores the last seen event for this node",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.Event"
        },
        "id": {
          "description": "ID is a unique identifier of a node within a sensor It is a hash of the node name",
          "type": "string"
        },
        "message": {
          "description": "store data or something to save for event notifications or trigger events",
          "type": "string"
        },
        "name": {
          "description": "Name is a unique name in the node tree used to generate the node ID",
          "type": "string"
        },
        "phase": {
          "description": "Phase of the node",
          "type": "string"
        },
        "resolvedAt": {
          "description": "ResolvedAt refers to the time at which the node was resolved.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "startedAt": {
          "description": "StartedAt is the time at which this node started",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        },
        "type": {
          "description": "Type is the type of the node",
          "type": "string"
        },
        "updatedAt": {
          "description": "UpdatedAt refers to the time at which the node was updated.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.OpenWhiskTrigger": {
      "description": "OpenWhiskTrigger refers to the specification of the OpenWhisk trigger.",
      "type": "object",
      "required": [
        "host",
        "actionName",
        "payload"
      ],
      "properties": {
        "actionName": {
          "description": "Name of the action/function.",
          "type": "string"
        },
        "authToken": {
          "description": "AuthToken for authentication.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        },
        "host": {
          "description": "Host URL of the OpenWhisk.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace for the action. Defaults to \"_\".",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "payload": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "version": {
          "description": "Version for the API. Defaults to v1.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.Sensor": {
      "description": "Sensor is the definition of a sensor resource",
      "type": "object",
      "required": [
        "metadata",
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.SensorSpec"
        },
        "status": {
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.SensorStatus"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.SensorList": {
      "description": "SensorList is the list of Sensor resources",
      "type": "object",
      "required": [
        "metadata",
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.Sensor"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.SensorResources": {
      "description": "SensorResources holds the metadata of the resources created for the sensor",
      "type": "object",
      "properties": {
        "deployment": {
          "description": "Deployment holds the metadata of the deployment for the sensor",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "service": {
          "description": "Service holds the metadata of the service for the sensor",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.SensorSpec": {
      "description": "SensorSpec represents desired sensor state",
      "type": "object",
      "required": [
        "dependencies",
        "triggers"
      ],
      "properties": {
        "circuit": {
          "description": "Circuit is a boolean expression of dependency groups",
          "type": "string"
        },
        "dependencies": {
          "description": "Dependencies is a list of the events that this sensor is dependent on.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.EventDependency"
          }
        },
        "dependencyGroups": {
          "description": "DependencyGroups is a list of the groups of events.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.DependencyGroup"
          }
        },
        "errorOnFailedRound": {
          "description": "ErrorOnFailedRound if set to true, marks sensor state as `error` if the previous trigger round fails. Once sensor state is set to `error`, no further triggers will be processed.",
          "type": "boolean"
        },
        "serviceAnnotations": {
          "description": "ServiceAnnotations refers to annotations to be set for the service generated",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "serviceLabels": {
          "description": "ServiceLabels to be set for the service generated",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "subscription": {
          "description": "Subscription refers to the modes of events subscriptions for the sensor. At least one of the types of subscription must be defined in order for sensor to be meaningful.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.Subscription"
        },
        "template": {
          "description": "Template is the pod specification for the sensor",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.Template"
        },
        "triggers": {
          "description": "Triggers is a list of the things that this sensor evokes. These are the outputs from this sensor.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.Trigger"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.SensorStatus": {
      "description": "SensorStatus contains information about the status of a sensor.",
      "type": "object",
      "required": [
        "phase",
        "triggerCycleStatus",
        "lastCycleTime"
      ],
      "properties": {
        "completedAt": {
          "description": "CompletedAt is the time at which this sensor was completed",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "lastCycleTime": {
          "description": "LastCycleTime is the time when last trigger cycle completed",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "message": {
          "description": "Message is a human readable string indicating details about a sensor in its phase",
          "type": "string"
        },
        "nodes": {
          "description": "Nodes is a mapping between a node ID and the node's status it records the states for the FSM of this sensor.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.NodeStatus"
          }
        },
        "phase": {
          "description": "Phase is the high-level summary of the sensor.",
          "type": "string"
        },
        "resources": {
          "description": "Resources refers to metadata of the resources created for the sensor",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.SensorResources"
        },
        "startedAt": {
          "description": "StartedAt is the time at which this sensor was initiated",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        },
        "triggerCycleCount": {
          "description": "TriggerCycleCount is the count of sensor's trigger cycle runs.",
          "type": "integer",
          "format": "int32"
        },
        "triggerCycleStatus": {
          "description": "TriggerCycleState is the status from last cycle of triggers execution.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.SlackTrigger": {
      "description": "SlackTrigger refers to the specification of the slack notification trigger.",
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel refers to which Slack channel to send slack message.",
          "type": "string"
        },
        "message": {
          "description": "Message refers to the message to send to the Slack channel.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace to read the password secret from. This is required if the password secret selector is specified.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "slackToken": {
          "description": "SlackToken refers to the Kubernetes secret that holds the slack token required to send messages.",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecretKeySelector"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.StandardK8STrigger": {
      "description": "StandardK8STrigger is the standard Kubernetes resource trigger",
      "type": "object",
      "required": [
        "group",
        "version",
        "resource"
      ],
      "properties": {
        "group": {
          "type": "string"
        },
        "liveObject": {
          "description": "LiveObject specifies whether the resource should be directly fetched from K8s instead of being marshaled from the resource artifact. If set to true, the resource artifact must contain the information required to uniquely identify the resource in the cluster, that is, you must specify \"apiVersion\", \"kind\" as well as \"name\" and \"namespace\" meta data. Only valid for operation type `update`",
          "type": "boolean"
        },
        "operation": {
          "description": "Operation refers to the type of operation performed on the k8s resource. Default value is Create.",
          "type": "string"
        },
        "parameters": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "patchStrategy": {
          "description": "PatchStrategy controls the K8s object patching strategy when the trigger operation is specified as patch. possible values: \"application/json-patch+json\" \"application/merge-patch+json\" \"application/strategic-merge-patch+json\" \"application/apply-patch+yaml\". Defaults to \"application/merge-patch+json\"",
          "type": "string"
        },
        "resource": {
          "type": "string"
        },
        "source": {
          "description": "Source of the K8 resource file(s)",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.ArtifactLocation"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.StatusPolicy": {
      "description": "StatusPolicy refers to the policy used to check the state of the trigger using response status",
      "type": "object",
      "required": [
        "allow"
      ],
      "properties": {
        "allow": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.Subscription": {
      "description": "Subscription holds different modes of subscription available for sensor to consume events.",
      "type": "object",
      "properties": {
        "http": {
          "description": "HTTP refers to the HTTP subscription of events for the sensor.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.HTTPSubscription"
        },
        "nats": {
          "description": "NATS refers to the NATS subscription of events for the sensor",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.NATSSubscription"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TLSConfig": {
      "description": "TLSConfig refers to TLS configuration for the HTTP client",
      "type": "object",
      "required": [
        "caCertPath",
        "clientCertPath",
        "clientKeyPath"
      ],
      "properties": {
        "caCertPath": {
          "description": "CACertPath refers the file path that contains the CA cert.",
          "type": "string"
        },
        "clientCertPath": {
          "description": "ClientCertPath refers the file path that contains client cert.",
          "type": "string"
        },
        "clientKeyPath": {
          "description": "ClientKeyPath refers the file path that contains client key.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.Template": {
      "description": "Template holds the information of a sensor deployment template",
      "type": "object",
      "properties": {
        "container": {
          "description": "Container is the main container image to run in the gateway pod",
          "$ref": "#/definitions/io.k8s.api.core.v1.Container"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSecurityContext"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run gateway pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "spec": {
          "description": "Spec holds the sensor deployment spec. DEPRECATED: Use Container instead.",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSpec"
        },
        "volumes": {
          "description": "Volumes is a list of volumes that can be mounted by containers in a workflow.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Volume"
          },
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TimeFilter": {
      "description": "TimeFilter describes a window in time. DataFilters out event events that occur outside the time limits. In other words, only events that occur after Start and before Stop will pass this filter.",
      "type": "object",
      "properties": {
        "start": {
          "description": "Start is the beginning of a time window. Before this time, events for this event are ignored and format is hh:mm:ss",
          "type": "string"
        },
        "stop": {
          "description": "StopPattern is the end of a time window. After this time, events for this event are ignored and format is hh:mm:ss",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.Trigger": {
      "description": "Trigger is an action taken, output produced, an event created, a message sent",
      "type": "object",
      "properties": {
        "parameters": {
          "description": "Parameters is the list of parameters applied to the trigger template definition",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameter"
          }
        },
        "policy": {
          "description": "Policy to configure backoff and execution criteria for the trigger",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerPolicy"
        },
        "template": {
          "description": "Template describes the trigger specification.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerTemplate"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TriggerParameter": {
      "description": "TriggerParameter indicates a passed parameter to a service template",
      "type": "object",
      "required": [
        "dest"
      ],
      "properties": {
        "dest": {
          "description": "Dest is the JSONPath of a resource key. A path is a series of keys separated by a dot. The colon character can be escaped with '.' The -1 key can be used to append a value to an existing array. See https://github.com/tidwall/sjson#path-syntax for more information about how this is used.",
          "type": "string"
        },
        "operation": {
          "description": "Operation is what to do with the existing value at Dest, whether to 'prepend', 'overwrite', or 'append' it.",
          "type": "string"
        },
        "src": {
          "description": "Src contains a source reference to the value of the parameter from a dependency",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerParameterSource"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TriggerParameterSource": {
      "description": "TriggerParameterSource defines the source for a parameter from a event event",
      "type": "object",
      "required": [
        "dependencyName"
      ],
      "properties": {
        "contextKey": {
          "description": "ContextKey is the JSONPath of the event's (JSON decoded) context key ContextKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'. See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
          "type": "string"
        },
        "contextTemplate": {
          "description": "ContextTemplate is a go-template for extracting a string from the event's context. If a ContextTemplate is provided with a ContextKey, the template will be evaluated first and fallback to the ContextKey. The templating follows the standard go-template syntax as well as sprig's extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/",
          "type": "string"
        },
        "dataKey": {
          "description": "DataKey is the JSONPath of the event's (JSON decoded) data key DataKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'. To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'. See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.",
          "type": "string"
        },
        "dataTemplate": {
          "description": "DataTemplate is a go-template for extracting a string from the event's data. If a DataTemplate is provided with a DataKey, the template will be evaluated first and fallback to the DataKey. The templating follows the standard go-template syntax as well as sprig's extra functions. See https://pkg.go.dev/text/template and https://masterminds.github.io/sprig/",
          "type": "string"
        },
        "dependencyName": {
          "description": "DependencyName refers to the name of the dependency. The event which is stored for this dependency is used as payload for the parameterization. Make sure to refer to one of the dependencies you have defined under Dependencies list.",
          "type": "string"
        },
        "value": {
          "description": "Value is the default literal value to use for this parameter source This is only used if the DataKey is invalid. If the DataKey is invalid and this is not defined, this param source will produce an error.",
          "type": "string"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TriggerPolicy": {
      "description": "TriggerPolicy dictates the policy for the trigger retries",
      "type": "object",
      "properties": {
        "k8s": {
          "description": "K8SResourcePolicy refers to the policy used to check the state of K8s based triggers using using labels",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.K8SResourcePolicy"
        },
        "status": {
          "description": "Status refers to the policy used to check the state of the trigger using response status",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.StatusPolicy"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TriggerSwitch": {
      "description": "TriggerSwitch describes condition which must be satisfied in order to execute a trigger. Depending upon condition type, status of dependency groups is used to evaluate the result.",
      "type": "object",
      "properties": {
        "all": {
          "description": "All acts as a AND operator between dependencies",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "any": {
          "description": "Any acts as a OR operator between dependencies",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.TriggerTemplate": {
      "description": "TriggerTemplate is the template that describes trigger specification.",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "argoWorkflow": {
          "description": "ArgoWorkflow refers to the trigger that can perform various operations on an Argo workflow.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.ArgoWorkflowTrigger"
        },
        "awsLambda": {
          "description": "AWSLambda refers to the trigger designed to invoke AWS Lambda function with with on-the-fly constructable payload.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.AWSLambdaTrigger"
        },
        "custom": {
          "description": "CustomTrigger refers to the trigger designed to connect to a gRPC trigger server and execute a custom trigger.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.CustomTrigger"
        },
        "http": {
          "description": "HTTP refers to the trigger designed to dispatch a HTTP request with on-the-fly constructable payload.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.HTTPTrigger"
        },
        "k8s": {
          "description": "StandardK8STrigger refers to the trigger designed to create or update a generic Kubernetes resource.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.StandardK8STrigger"
        },
        "kafka": {
          "description": "Kafka refers to the trigger designed to place messages on Kafka topic.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.KafkaTrigger"
        },
        "name": {
          "description": "Name is a unique name of the action to take.",
          "type": "string"
        },
        "nats": {
          "description": "NATS refers to the trigger designed to place message on NATS subject.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.NATSTrigger"
        },
        "openWhisk": {
          "description": "OpenWhisk refers to the trigger designed to invoke OpenWhisk action.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.OpenWhiskTrigger"
        },
        "slack": {
          "description": "Slack refers to the trigger designed to send slack notification message.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.SlackTrigger"
        },
        "switch": {
          "description": "Switch is the condition to execute the trigger.",
          "$ref": "#/definitions/io.argoproj.sensor.v1alpha1.TriggerSwitch"
        }
      }
    },
    "io.argoproj.sensor.v1alpha1.URLArtifact": {
      "description": "URLArtifact contains information about an artifact at an http endpoint.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "Path is the complete URL",
          "type": "string"
        },
        "verifyCert": {
          "description": "VerifyCert decides whether the connection is secure or not",
          "type": "boolean"
        }
      }
    }
  }
}
